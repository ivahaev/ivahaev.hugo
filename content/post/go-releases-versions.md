+++
date = "2016-07-01T23:11:50+05:00"
title = "Версионирование go программ"
slug = "go-releases-versions"

tags = [ "go", "golang", "SemVer", "node.js", "npm", "git" ]
+++

Читая новости [на отличном ресурсе по Go](http://4gophers.ru/), наткнулся на статью Дейва Чени [Гоферы, тэгируйте свои релизы](http://dave.cheney.net/2016/06/24/gophers-please-tag-your-releases). Вкратце, там говорится о полезности тэгов к комитам пакета в git репозитории.

Что самое интересное, статья написана 24 июня, примерно в то же время, может быть, днём ранее, я написал инструмент для себя, который позволяет автоматизировать процесс изменения версии приложений, написанных на [Go](https://golang.org/).

<!--more-->

Вдохновил меня на этот поступок, как ни странно, инструмент из мира [node.js](https://nodejs.org)&nbsp;&mdash; [npm](https://www.npmjs.com/). Дело в том, что **npm** имеет в своём арсенале команду `version patch`, которая делает три простые и очень нужные вещи для npm пакетов:

*   Увеличивает на единичку в файле **package.json** версию патча, согласно [SemVer 2.0.0](http://semver.org/spec/v2.0.0.html);
*   Комитит файла **package.json**;
*   Навешивает на комит тэг, соответствующий версии в **package.json**.

В нашем главном проекте [Blank](http://getblank.net), в npm пакетах, мы дописали скрипты в файл **package.json** для автоматической заливки изменений на [github](https://github.com/).

```JSON
  "scripts": {
    "patch": "npm version patch && npm run push",
    "push": "git push origin master --follow-tags && npm publish"
  }
```

Таким образом, для того, чтобы &laquo;зарелизить&raquo; новую версию своего приложения, достаточно написать в корне проекта:

```
> npm run patch
```

NPM остальное сделает сам&nbsp;&mdash; увеличит версию патча, сделает комит, навесит тэг с версией и отправит на github.

Мне эта штука так понравилась, что, не найдя ничего похожего для **Go**, я решил сделать подобный инструмент для гоферов. Итак, представляю [patcher](https://github.com/ivahaev/patcher).

Что он делает:

*   В файле **main.go** в корне проекта ищет переменную **version** и увеличивает на единицу третий её сегмен (версию патча);
*   Комитит файл **main.go** с сообщением **Version update: ЗНАЧЕНИЕ_ПЕРЕМЕННОЙ_version**;
*   Навешивает к комиту тэг **vЗНАЧЕНИЕ_ПЕРЕМЕННОЙ_version**;

Кроме того, при запуске с ключом **-p** (`patcher -p`), утилита тут же отправит все изменения в удалённый репозиторий. Вот так всё просто.

Далее уже можно настроить систему непрерывной интеграции, например, на сборку тэгированных релизов с автоматическим обновлением сервисов, либо с публикацией на ресурсах для скачивания приложения.

Установка производится как обычно:

```
> go get github.com/ivahaev/patcher
```

Если `$GOPATH/bin` находится в вашем `$PATH`, запуск производится из командной строки

```
> patcher [filename [varName]] [-p]
```

Или если в `$PATH` не прописаны пути:

```
> $GOPATH/bin/patcher [filename [varName]] [-p]
```

Есть два необязательных параметра&nbsp;&mdash; имя файла, в котором находится переменная с версией и, имя самой переменной с версией приложения. По-умолчанию, эти параметры равны **main.go** и **version**, соответственно. Также, если указать ключ **-p**, утилита автоматически отправит изменения в удалённый репозиторий.

Я использую эту утилиту каждый день и она делает мою жизнь гораздо ярче, чего и вам желаю :).

В другой раз расскажу о том, как всё это используется для непрерывной интеграции в наших проектах.