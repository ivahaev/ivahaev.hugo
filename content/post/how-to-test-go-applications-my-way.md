+++
date = "2016-07-08T03:11:50+05:00"
title = "Мой подход к тестированию"
slug = "how-to-test-go-applications-my-way"
draft = true

tags = [ "go", "golang", "test", "testing", "mocha", "node.js", "javascript", "goblin" ]
+++

Сколько бы я не пытался &laquo;в прошлой жизни&raquo; заставить себя писать тесты, получалось довольно плохо. Точнее, оно получалось, но как-то всё хромало, как у Винни-Пуха правильнописание. Казалось, что быстрее и проще потыкать в браузере, или там клавиши понажимать, проверить, а дальше просто будет работать.

По мере усложнения создаваемых приложений, логика становилась всё замудрённее, времени на такое вот &laquo;протыкивание&raquo; стало уходить всё больше. Каким-то своим отдельным путём я пришёл к тому, что стал писать мелкие отдельные файлы, которые выполняли некоторые функции из проекта и проверяли вывод на корректность. Таким образом, я для себя открыл юнит тестирование. Проблема была в том, что тесты необходимо поддерживать в актуальном состоянии, модифицировать вместе с основным кодом, а ведь кажется, что есть гораздо более важные задачи на данный момент.

В мае 2016 года было принято решение начать писать тесты в принудительном порядке, тем более, что исходные тексты новой версии нашей платформы Blank мы открыли сразу, а в грязь лицом ударить не хочется.

<!--more-->

С подситемой на [Node.js](https://nodejs.org) вопросов никаких не возникло. Есть стандарт&nbsp;&mdash; [Mocha](mochajs.org) (по-русски лучше не читать :) с понятным синтаксисом и весьма приятным форматированием результатов тестирования. Ну и, конечно, стандартный модуль [Assert](https://nodejs.org/api/assert.html) для непосредственно проверок.


С [Go](https://golang.org/) ситуация несколько иная. Стандартная поставка уже имеет средства для оформления и запуска тестов. Я сейчас говорю о стандартном пакете [testing](https://golang.org/pkg/testing/), в котором есть даже средства для замера производительности кода. Всё, что требуется&nbsp;&mdash; это создать рядом с тестируемым кодом файл с именем, _оканчивающимся_ на **_test.go**, например, **app_test.go**, а в нем должны быть функции, _начинающиеся_ на Test и получающие на вход указатель на структуру `testing.T`, которой можно, например, &laquo;завалить&raquo; тест.


Например:

```go
package app

import "testing"

func TestSomeFunc(t *testing.T) {
    expected := "aa"
    value := someFunc()
    if value != expected {
        t.Fatal("Achtung! value != expected")
    }
}
```

В общем случае, чтобы запустить тестирование, достаточно выполнить команду `go test`. Если все отлично, мы увидим нечно вроде **PASS** в консоли, что означает, что тесты выполнились успешно.

Вроде бы, никаких проблем, тест читаемый &nbsp;&mdash;  вот это не равно вот этому, поэтому это плохо. Смысл теста можно вложить в название тест-функции. Но после  **Mocha** хочется какого-то бо&#769;льшего удовлетворения. Чтобы красиво вывести все проверки. Чтобы можно было подробнее описать что именно тестируем и почему такой-то результат ожидаем.

Поиск инструмента я начал с ресурса [Awesome Go](https://github.com/avelino/awesome-go), там вообще много чего интересного можно найти, а иногда даже и полезного. Перебрал кучу тестирующих фреймворков, пока не дошёл до [Гоблина](https://github.com/franela/goblin). Т.к. мы договорились не называть по-русски другой фреймворк, то скажу дословно, как рассказывают о Гоблине его содатели:

> A Mocha like BDD testing framework for Go

Если это правда, то это то, что мне нужно! В принципе, это оказалось правдой.