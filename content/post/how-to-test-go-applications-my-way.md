+++
date = "2016-07-08T03:11:50+05:00"
title = "Мой подход к тестированию"
slug = "how-to-test-go-applications-my-way"
draft = true

tags = [ "go", "golang", "test", "testing", "mocha", "node.js", "javascript", "goblin" ]
+++

Сколько бы я не пытался &laquo;в прошлой жизни&raquo; заставить себя писать тесты, получалось довольно плохо. Точнее, оно получалось, но как-то всё хромало, как у Винни-Пуха правильнописание. Казалось, что быстрее и проще потыкать в браузере, или там клавиши понажимать, проверить, а дальше просто будет работать.

По мере усложнения создаваемых приложений, логика становилась всё замудрённее, времени на такое вот &laquo;протыкивание&raquo; стало уходить всё больше. Каким-то своим отдельным путём я пришёл к тому, что стал писать мелкие отдельные файлы, которые выполняли некоторые функции из проекта и проверяли вывод на корректность. Таким образом, я для себя открыл юнит тестирование. Проблема была в том, что тесты необходимо поддерживать в актуальном состоянии, модифицировать вместе с основным кодом, а ведь кажется, что есть гораздо более важные задачи на данный момент.

В мае 2016 года было принято решение начать писать тесты в принудительном порядке, тем более, что исходные тексты новой версии нашей платформы Blank мы открыли сразу, а в грязь лицом ударить не хочется.

<!--more-->

С подситемой на [Node.js](https://nodejs.org) вопросов никаких не возникло. Есть стандарт&nbsp;&mdash; [Mocha](mochajs.org) (по-русски лучше не читать :) с понятным синтаксисом и весьма приятным форматированием результатов тестирования. Ну и, конечно, стандартный модуль [Assert](https://nodejs.org/api/assert.html) для непосредственно проверок.


С [Go](https://golang.org/) ситуация несколько иная. Стандартная поставка уже имеет средства для оформления и запуска тестов. Я сейчас говорю о стандартном пакете [testing](https://golang.org/pkg/testing/), в котором есть даже средства для замера производительности кода. Всё, что требуется&nbsp;&mdash; это создать рядом с тестируемым кодом файл с именем, _оканчивающимся_ на `_test.go`, например, `app_test.go`, а в нем должны быть функции, _начинающиеся_ на `Test` и получающие на вход указатель на структуру `testing.T`, с помощбю методов которой можно, например, &laquo;завалить&raquo; тест. Во время компилляции, такие файлы игнорируются.

Например, у нас есть пакет с единственным методом, складывающим два положительных целых числа. В случае, если одно из чисел окажется отрицательным, функция вернёт ошибку. Понятно, что в реальной жизни функции должны делать что-то более полезное, но для объяснения сути, так даже лучше:

```go
// adder.go
package adder

import "errors"

func AddPositive(a, b int) (int, error) {
    if a < 0 || b < 0 {
        return 0, errors.New("only positive integers allowed")
    }
    return a + b, nil
}

```

Напишем тесты:

```go
// adder_test.go
package adder

import "testing"

func TestAddPositiveSuccess(t *testing.T) {
	expected := 5
	res, err := AddPositive(2, 3)
	if err != nil {
		t.Fatal(err)
	}
	if res != expected {
		t.Fatal("Achtung! value != expected")
	}
}

func TestAddPositiveFail(t *testing.T) {
	_, err := AddPositive(2, -3)
	if err == nil {
		t.Fatal("must return error")
	}
}
```

В общем случае, чтобы запустить тестирование, достаточно выполнить команду `go test`. Если все отлично, мы увидим нечно вроде **PASS** в консоли, что означает, что тесты выполнились успешно.

```bash
bash-3.2$ go test
PASS
ok  	_/tmp/adder	0.018s
```
Не очень-то информативно.


Вроде бы, никаких проблем, тест читаемый&nbsp;&mdash; если произошла ошибка, или результат выполнения функции не тот, что ожидали, то всё плохо. Смысл теста можно вложить в название тест-функции. Если тест будет завален, то в консоль будет выведена функция, в которой не прошли проверки и строка с соответствующей инструкцией `t.Fatal`.

```bash
bash-3.2$ go test
# _/tmp/adder
./adder_test.go:19: res declared and not used
FAIL	_/tmp/adder [build failed]
```

Но после  **Mocha** хочется какого-то бо&#769;льшего удовлетворения. Чтобы красиво вывести все проверки. Чтобы можно было подробнее описать что именно тестируем и почему такой-то результат ожидаем.

Поиск инструмента я начал с ресурса [Awesome Go](https://github.com/avelino/awesome-go), там вообще много чего интересного можно найти, а иногда даже и полезного. Перебрал кучу тестирующих фреймворков, пока не дошёл до [Гоблина](https://github.com/franela/goblin). Т.к. мы договорились не называть по-русски другой фреймворк, то скажу дословно, как рассказывают о Гоблине его содатели:

> A Mocha like BDD testing framework for Go

Если это правда, то это то, что мне нужно!

Перепишем наш тест с использованием Гоблина:

```go
package adder

import (
	"github.com/franela/goblin"
	"testing"
)

func TestAddPositive(t *testing.T) {
	g := goblin.Goblin(t)

	g.Describe("#AddPositive", func() {
		g.It("should return nil error and expected result when positive integer passed", func() {
			expected := 5
			res, err := AddPositive(2, 3)
			g.Assert(err == nil).IsTrue()
			g.Assert(res).Equal(expected)
		})

		g.It("should return error when negative integer passed", func() {
			_, err := AddPositive(2, -3)
			g.Assert(err == nil).IsFalse()
		})
	})
}

```

А теперь посмотрим на вывод команды `go test` в консоли:

```bash
bash-3.2$ go test

  #AddPositive
    ✔ should return nil error and expected result when positiv integer passed
    ✔ should return error when negative integer passed


 2 tests complete (0 ms)
PASS
ok  	_/tmp/adder	0.008s
```

На мой взгляд, гораздо приятнее. При этом ещё и красиво цветом выделяются пройдённые тесты. Что тест, что вывод в консоли говорит сам за себя&nbsp;&mdash; тестируем функцию `AddPositive`, которая должна выполниться без ошибки и вернуть ожидаемые результат, если на вход подаются положительные значения, а так же должна вернуть ошибку, если на вход подали что-то отрицательное.

Попробовав один раз, использую теперь Гоблина во всех проектах, я им очень доволен. При этом, Гоблин полностью совместим со стандартной библиотекой testing.

А теперь ещё один секрет. Есть довольно интересная штука, которая называется [GoConvey](http://goconvey.co/). Это тоже фреймворк для тестирования, но с несколько другой идеологией, которая мне не очень понравилась. Зато мне понравилось как GoConvey работает в связке с Гоблином. Установив программу, запускаем в корне проекта. GoConvey сам откроет браузер, где мы сможем наблюдать вот такую красоту:

![output](/img/goconvey_success.png)

Он сам запустит тесты во всех сабмодулях, выведет суммарный отчет, покажет степень покрытия кода тестами (у нас 100% покрытие, как мы видим :). При этом будет перезапускать тесты при каждом изменении исходного кода и тут же отображать результат в браузере!