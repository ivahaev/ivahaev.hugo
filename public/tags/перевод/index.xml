<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Перевод on ivahaev.ru</title>
    <link>http://ivahaev.github.io/ivahaev.ru/tags/%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4/</link>
    <description>Recent content in Перевод on ivahaev.ru</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-RU</language>
    <lastBuildDate>Thu, 12 Nov 2015 01:32:28 +0500</lastBuildDate>
    <atom:link href="http://ivahaev.github.io/ivahaev.ru/tags/%D0%BF%D0%B5%D1%80%D0%B5%D0%B2%D0%BE%D0%B4/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Три частые ошибки, возникающие при разработке на Go</title>
      <link>http://ivahaev.github.io/ivahaev.ru/2015/11/12/three-often-mistakes-wth-go</link>
      <pubDate>Thu, 12 Nov 2015 01:32:28 +0500</pubDate>
      
      <guid>http://ivahaev.github.io/ivahaev.ru/2015/11/12/three-often-mistakes-wth-go</guid>
      <description>

&lt;p&gt;Это перевод статьи. Раньше желания переводить не возникало, но статья очень понравилась, наверное, из-за того, что сам наступал уже на подобные грабли. Перевод достаточно вольный, но суть передает верно. Если хоть одному начинающему разработчику поможет эта статья, труды мои будут не напрасными :).&lt;/p&gt;

&lt;p&gt;Оригинал статьи доступен по адресу &lt;a href=&#34;http://bryce.is/writing/code/jekyll/update/2015/11/01/3-go-gotchas.html&#34;&gt;http://bryce.is/writing/code/jekyll/update/2015/11/01/3-go-gotchas.html&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;1-итерация-через-range:09760c5f9427cb3b4e256b9be52ce692&#34;&gt;1. Итерация через range&lt;/h2&gt;

&lt;p&gt;Использовать &lt;code&gt;range&lt;/code&gt; очень удобно. Перебирая срез или отображение, для каждого элемента мы получаем две переменные, в первой индекс элемента, во второй &lt;strong&gt;копия&lt;/strong&gt; значения.
Например:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index, value := range mySlice {
    fmt.Println(&amp;quot;index: &amp;quot; + index)
    fmt.Println(&amp;quot;value: &amp;quot; + value)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Но что же здесь происходит на самом деле? Рассмотрим более подробный пример:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Foo struct {
    bar string
}

func main() {
    list := []Foo{
        {&amp;quot;A&amp;quot;},
        {&amp;quot;B&amp;quot;},
        {&amp;quot;C&amp;quot;},
    }

    list2 := make([]*Foo, len(list))
    for i, value := range list {
        list2[i] = &amp;amp;value
    }

    fmt.Println(list[0], list[1], list[2])
    fmt.Println(list2[0], list2[1], list2[2])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В данном примере происходит следующее:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Создается срез структур &lt;code&gt;Foo&lt;/code&gt; под названием &lt;code&gt;list&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Определяется срез указателей на структуры &lt;code&gt;Foo&lt;/code&gt;, под названием &lt;code&gt;list2&lt;/code&gt; с длиной равной длине массива &lt;code&gt;list&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Перебираем все структуры в срезе &lt;code&gt;list&lt;/code&gt; и присваиваем указатель на структуру соответствующему элементу среза &lt;code&gt;list2&lt;/code&gt; (имеющему тот же индекс);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вероятнее всего, мы ожидаем следующий результат работы вышеприведенного кода:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{A} {B} {C}
&amp;amp;{A} &amp;amp;{B} &amp;amp;{C}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;А на самом деле, получаем:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{A} {B} {C}
&amp;amp;{C} &amp;amp;{C} &amp;amp;{C}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Первая строка именно такая как ожидалась, а вот со второй что-то не так. Как будто бы распечатался указатель на третий элемент среза &lt;code&gt;list2&lt;/code&gt; три раза. Почему же такое произошло?&lt;/p&gt;

&lt;p&gt;Всему виной этот самый удобный &lt;code&gt;range&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i, value := range list {
    list2[i] = &amp;amp;value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go передает &lt;strong&gt;копий&lt;/strong&gt; значений элементов вместо самих значений, когда производится итерация с помощью &lt;code&gt;range&lt;/code&gt;. И когда мы создаем указатель на &lt;code&gt;value&lt;/code&gt;, на самом деле, мы создаем указатель на &lt;strong&gt;копию&lt;/strong&gt; значения. При каждой итерации, копия нового значения помещается в ту же ячейку памяти, что и предыдущее, таким образом, все указатели в срезе &lt;code&gt;list2&lt;/code&gt; приводят к одной области памяти.&lt;/p&gt;

&lt;p&gt;Правильно решить поставленную задачу можно так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var value Foo
for var i := 0; i &amp;lt; len(list); i++ {
    value = list[i]
    list2[i] = &amp;amp;value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Или, все-таки, с помощью &lt;code&gt;range&lt;/code&gt;, но взяв из него только индекс элемента:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i := range list {
    list2[i] = &amp;amp;list[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-использование-встроенной-функций-append:09760c5f9427cb3b4e256b9be52ce692&#34;&gt;2. Использование встроенной функций append&lt;/h2&gt;

&lt;p&gt;Срезы&amp;nbsp;&amp;mdash; один из примитивных типов в Go. То что в других языках делается с массивами, в гоу можно сделать только со срезом.
Например, нам нужно добавить значение в срез элементов типа &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list := []int{0,1,2}
list = append(list, 3)
fmt.Println(list) // [0 1 2 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На первый взгляд, все похоже на метод &lt;code&gt;push()&lt;/code&gt; для массивов в других языках, но срезы&amp;nbsp;&amp;mdash; это не совсем массивы и функция &lt;code&gt;append&lt;/code&gt; иногда может удивить.&lt;/p&gt;

&lt;p&gt;Рассмотрим другой пример:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    a := []byte(&amp;quot;foo&amp;quot;)
    b := append(a, []byte(&amp;quot;bar&amp;quot;)...)
    c := append(a, []byte(&amp;quot;baz&amp;quot;)...)

    fmt.Println(string(a), string(b), string(c))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Здесь мы определили срез байт и сразу же инициировали его, преобразовав в срез строку &lt;strong&gt;&amp;ldquo;foo&amp;rdquo;&lt;/strong&gt;. Далее мы добавляем срез &lt;strong&gt;[&amp;ldquo;bar&amp;rdquo;]&lt;/strong&gt; к первому срезу, присваиваем полученное переменной &lt;code&gt;b&lt;/code&gt;, после чего добавляем другой срез &lt;strong&gt;[&amp;ldquo;baz&amp;rdquo;]&lt;/strong&gt; также к первому срезу и присваиваем полученное переменной &lt;code&gt;c&lt;/code&gt;. Результатом работы данной программы будет следующее:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo foobaz foobaz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://ivahaev.github.io/ivahaev.ru/img/shta.jpeg&#34; alt=&#34;Шта?&#34; /&gt;
Какого? Мы-то ждали &lt;code&gt;foo foobar foobaz&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;Чтобы понять что произошло, следует разобраться с тем, а что же за звери такие эти срезы? Срез в Go&amp;nbsp;&amp;mdash; это дексриптор, который содержит три компонента:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Указатель на базовый &lt;strong&gt;массив&lt;/strong&gt; элементов. К этому массиву мы не получим прямого доступа;&lt;/li&gt;
&lt;li&gt;Емкость базового массива;&lt;/li&gt;
&lt;li&gt;Длину среза.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Так что же произошло на самом деле? Go переиспользует базовый массив в функции &lt;code&gt;append&lt;/code&gt; если он может сделать это не изменяя его емкости. Все три переменные в примере указывают на одну и ту же области памяти. Единственная разница, что срез &lt;code&gt;a&lt;/code&gt; имеет длину &lt;strong&gt;3&lt;/strong&gt;, а срезы &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; длину равную 6.&lt;/p&gt;

&lt;p&gt;Следует всегда помнить, что Go будет использовать тот же базовый массив, если длина нового среза будет меньшей или равной емкости изначального среза.&lt;/p&gt;

&lt;h2 id=&#34;3-затенение-переменных:09760c5f9427cb3b4e256b9be52ce692&#34;&gt;3. Затенение переменных&lt;/h2&gt;

&lt;p&gt;Не уверен в переводе термина (&lt;strong&gt;Variable shadowing&lt;/strong&gt;), но примерно как-то так.&lt;/p&gt;

&lt;p&gt;В Go есть один интересный оператор, который выглядит вот так: &lt;code&gt;:=&lt;/code&gt;. Из-за него некоторые говорят, что Go очень похож на Pascal, хотя в Go оператор выполняет несколько другую работу. &lt;code&gt;:=&lt;/code&gt;&amp;nbsp;&amp;mdash; это короткая форма объявления переменной с одновременным присвоением значения и типа, соответствующего переданному значению. Очень удобная форма записи, но, к сожалению, именно она и таит в себе возможность совершить ошибку.&lt;/p&gt;

&lt;p&gt;Рассмотрим следующий код:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    list := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}
    for {
        list, err := repeat(list)
        if err != nil {
            panic(err)
        }
        fmt.Println(list)
        break
    }
    fmt.Println(list)
}

func repeat(list []string) ([]string, error) {
    if len(list) == 0 {
        return nil, errors.New(&amp;quot;Nothing to repeat!&amp;quot;)
    }
    list = append(list, list...)
    return list, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Автор считает, что это очень показательный пример. Ну что же, поверим, к тому же, он вполне себе хорошо иллюстрирует проблему. Происходит следующее:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Создается срез строк с именем &lt;code&gt;list&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Запускается бесконечный цикл;&lt;/li&gt;
&lt;li&gt;Вызываем функцию &lt;code&gt;repeat()&lt;/code&gt;, которая возвращает новый срез и ошибку;&lt;/li&gt;
&lt;li&gt;Прерываем цикл;&lt;/li&gt;
&lt;li&gt;Печатаем &lt;code&gt;list&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Глядя на код, ожидается следующий вывод:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[a b c a b c]
[a b c a b c]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Но на деле получаем:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[a b c a b c]
[a b c]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;А все потому, что когда использовали оператор &lt;code&gt;:=&lt;/code&gt;, мы на самом деле определили новую переменную &lt;code&gt;list&lt;/code&gt; в области видимости цикла. В Go фигурные скобки создают новую область видимости. Мы это сделали для того, чтобы быстренько объявить переменную &lt;code&gt;err&lt;/code&gt; типа &lt;code&gt;error&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ivahaev.github.io/ivahaev.ru/img/norma.jpeg&#34; alt=&#34;Это норма&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Чтобы исправить ситуацию, нужно объявить &lt;code&gt;err&lt;/code&gt; заранее и далее использовать обычный оператор присваивания &lt;code&gt;=&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var err error
list, err = duplicate(list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В поставке Go есть отличная утилита &lt;code&gt;go vet&lt;/code&gt;, запустив которую с опцией &lt;code&gt;-shadow&lt;/code&gt;, можно проверить код на наличие потенциальных ошибок связанных с затенением переменных.&lt;/p&gt;

&lt;p&gt;Go&amp;nbsp;&amp;mdash; отличный язык, но чтобы создавать действительно классно работающие приложения, стоит понимать что происходит у него &amp;ldquo;под капотом&amp;rdquo;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>