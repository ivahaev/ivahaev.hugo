<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on ivahaev.ru</title>
    <link>http://ivahaev.ru/tags/go/</link>
    <description>Recent content in Go on ivahaev.ru</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-RU</language>
    <copyright>2016 Евгений Иваха</copyright>
    <lastBuildDate>Sun, 01 May 2016 14:12:32 +0500</lastBuildDate>
    <atom:link href="http://ivahaev.ru/tags/go/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Прокаченный таймер на Go</title>
      <link>http://ivahaev.ru/post/advanced-go-timer/</link>
      <pubDate>Sun, 01 May 2016 14:12:32 +0500</pubDate>
      
      <guid>http://ivahaev.ru/post/advanced-go-timer/</guid>
      <description>&lt;p&gt;У языка &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; шикарная стандартная библиотека, инструменты на все случаи жизни, при этом достаточно лаконичные. Например, рассмотрим отличный пакет &lt;a href=&#34;https://golang.org/pkg/time/&#34;&gt;time&lt;/a&gt;. За всё время работы с &lt;strong&gt;Go&lt;/strong&gt;, мне всего лишь дважды приходилось расширять его возможности.&lt;/p&gt;

&lt;p&gt;Первый раз, около года назад, понадобилось строковое представление времени и периодов на русском языке, что привело к созданию пакета &lt;a href=&#34;https://github.com/ivahaev/russian-time&#34;&gt;russian-time&lt;/a&gt;. Он не очень красивый, создан на скорую руку, потому не буду на нём останавливаться сегодня.&lt;/p&gt;

&lt;p&gt;Второй инструмент, мне кажется более интересным. Предпосылкой к созданию этого небольшого пакета, была необходимость контроля времени выполнения скриптов во встроенном интерпретаторе &lt;strong&gt;JavaScript&lt;/strong&gt; &lt;strong&gt;Google V8&lt;/strong&gt;. Так уж повелось, что &lt;strong&gt;JavaScript&lt;/strong&gt;, как правило, характеризуется асинхронным поведением, что несколько затрудняло выполнение поставленной задачи. Одним из компонентов решения должен был стать таймер, который можно приостанавливать на неопределённое время, а после запускать снова с момента остановки. Так появился &lt;a href=&#34;https://github.com/ivahaev/timer&#34;&gt;timer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Функции &lt;a href=&#34;https://godoc.org/github.com/ivahaev/timer#AfterFunc&#34;&gt;AfterFunc&lt;/a&gt;  и &lt;a href=&#34;https://godoc.org/github.com/ivahaev/timer#NewTimer&#34;&gt;NewTimer&lt;/a&gt;  очень похожи на стандартные, но у возвращаемого указателя на структуру &lt;a href=&#34;https://godoc.org/github.com/ivahaev/timer#Timer&#34;&gt;Timer&lt;/a&gt; есть два новых метода:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/ivahaev/timer#Timer.Pause&#34;&gt;Pause&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/ivahaev/timer#Timer.Start&#34;&gt;Start&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Pause&lt;/strong&gt; приостанавливает выполнение таймера, а &lt;strong&gt;Start&lt;/strong&gt;, соответственно, запускает его с момента остановки, либо после инициализации. Т.е. после создания таймера, запускать его требуется вручную.&lt;/p&gt;

&lt;p&gt;Пример из теста лучше покажет идею:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var now = time.Now()

// Создаем таймер на 1 секунду
var timer = AfterFunc(time.Second, func() {

    // Сравниваем сколько прошло времени
	if time.Now().Sub(now) &amp;lt; time.Second*2 {
		panic(&amp;quot;Early func&amp;quot;)
	}
})

// Запускаем таймер
timer.Start()

// Через пол секунды приостанавливаем
time.Sleep(time.Microsecond * 500)
timer.Pause()

// Через секунду запускаем снова
time.Sleep(time.Second)
timer.Start()
time.Sleep(time.Second)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/ivahaev/timer&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/ivahaev/timer?status.svg&#34; alt=&#34;GoDoc&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>go-logger – простой и информативный логгер для Go</title>
      <link>http://ivahaev.ru/post/simple-logger-for-golang/</link>
      <pubDate>Mon, 18 Jan 2016 00:47:11 +0500</pubDate>
      
      <guid>http://ivahaev.ru/post/simple-logger-for-golang/</guid>
      <description>

&lt;p&gt;Не смотря на всё многообразие существующих логгеров для &lt;strong&gt;Go&lt;/strong&gt;, как-то не удалось подобрать удобный и подходящий для меня. Хотелось иметь инструмент, похожий на те, какими пользовался в других языках. Если хочешь сделать что-то хорошо, сделай это сам.&lt;/p&gt;

&lt;p&gt;Итак, мой &lt;a href=&#34;https://github.com/ivahaev/go-logger&#34;&gt;go-logger&lt;/a&gt;. Что он умеет и чем он лучше других:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Все методы логгирования принимают любое количество аргументов любых типов;&lt;/li&gt;
&lt;li&gt;Метод &lt;a href=&#34;https://godoc.org/github.com/ivahaev/go-logger#Debug&#34;&gt;Debug()&lt;/a&gt; красиво выводит данные. Если это структура, слайс или мапа, то будет наглядно видно что в них, если же это простая переменная, то увидим тип и размер;&lt;/li&gt;
&lt;li&gt;Отображается файл и строка в которой вызвано логгирование;&lt;/li&gt;
&lt;li&gt;Цветовое кодирование каждого уровня;&lt;/li&gt;
&lt;li&gt;Возможность изменить формат вывода даты.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;пример:7601b1667c165933f68b5b13c8315974&#34;&gt;Пример&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    package main

    import &amp;quot;github.com/ivahaev/go-logger&amp;quot;

    func main() {
        logger.SetLevel(&amp;quot;DEBUG&amp;quot;)

        logger.Debug(&amp;quot;Some string for debug&amp;quot;, 123, map[string]interface{}{&amp;quot;prop1&amp;quot;: &amp;quot;val1&amp;quot;, &amp;quot;prop2&amp;quot;: 321})
        logger.Info(&amp;quot;Some string for info&amp;quot;, 123, map[string]interface{}{&amp;quot;prop1&amp;quot;: &amp;quot;val1&amp;quot;, &amp;quot;prop2&amp;quot;: 321})
        logger.Notice(&amp;quot;Some string for debug&amp;quot;, 123, map[string]interface{}{&amp;quot;prop1&amp;quot;: &amp;quot;val1&amp;quot;, &amp;quot;prop2&amp;quot;: 321})
        logger.Warn(&amp;quot;Some string for warning&amp;quot;, 123, map[string]interface{}{&amp;quot;prop1&amp;quot;: &amp;quot;val1&amp;quot;, &amp;quot;prop2&amp;quot;: 321})
        logger.Error(&amp;quot;Some string for error&amp;quot;, 123, map[string]interface{}{&amp;quot;prop1&amp;quot;: &amp;quot;val1&amp;quot;, &amp;quot;prop2&amp;quot;: 321})
        logger.Crit(&amp;quot;Some string for critical&amp;quot;, 123, map[string]interface{}{&amp;quot;prop1&amp;quot;: &amp;quot;val1&amp;quot;, &amp;quot;prop2&amp;quot;: 321})
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот что получим в консоли:
&lt;img src=&#34;http://ivahaev.ru/img/logger-console.png&#34; alt=&#34;output&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Со временем добавлю возможность прятать файл вызова и строку, такие мысли уже посещали для продакшина. Может быть, что-то ещё, но пока этот логгер меня устраивает на 100%, я его использую во всех своих проектах. Возможно, пригодится и вам!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Amigo – лучший друг Golang и Asterisk</title>
      <link>http://ivahaev.ru/post/amigo-best-frend-of-golang-and-asterisk/</link>
      <pubDate>Thu, 14 Jan 2016 21:52:24 +0500</pubDate>
      
      <guid>http://ivahaev.ru/post/amigo-best-frend-of-golang-and-asterisk/</guid>
      <description>&lt;p&gt;Начиная писать свой первый &lt;a href=&#34;http://peach-dialer.com&#34;&gt;Peach Dialer&lt;/a&gt;, я выбрал язык, который довольно хорошо знал, благо работал с ним с 1999 года&amp;nbsp;&amp;mdash; &lt;strong&gt;PHP&lt;/strong&gt;. Меня не смущало, что он, в принципе, не предназначен для создания долгоживущих процессов, но то, что получилось в итоге, работает по несколько месяцев и радует своих владельцев.&lt;/p&gt;

&lt;p&gt;Потом пошла мода на &lt;a href=&#34;https://ru.wikipedia.org/wiki/WebSocket&#34;&gt;Websocket&lt;/a&gt;, который захотелось применить в интерфейсе, а &lt;strong&gt;PHP&lt;/strong&gt; в то время не очень-то умел с ними работать (может, и сейчас не умеет). Я обратил внимание на &lt;a href=&#34;https://nodejs.org&#34;&gt;node.js&lt;/a&gt;. Классная штука, любовь на века, подумал я, но вскоре захотелось большего.&lt;/p&gt;

&lt;p&gt;Бо&amp;#769;льшим для меня стал &lt;a href=&#34;https://golang.org&#34;&gt;Go&lt;/a&gt;&amp;nbsp;&amp;mdash; язык, совмещающий скорость и удобство деплоя компилируемых языков с простотой разработки, свойственной интерпретируемым языкам. К сожалению, разработанных библиотек надлежащего качества и с ожидаемым функционалом для взаимодействия с &lt;strong&gt;Asterisk&lt;/strong&gt; в то время не было. Были какие-то начинания, но не доведённые до конца.&lt;/p&gt;

&lt;p&gt;Итак, по сусекам поскребя, да по амбару пометя&amp;#769;, испёк я &lt;a href=&#34;https://github.com/ivahaev/amigo&#34;&gt;Amigo&lt;/a&gt;&amp;nbsp;&amp;mdash; удобную библиотеку для работы с астериском посредством AMI протокола.&lt;/p&gt;

&lt;p&gt;Установка библиотеки:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get github.com/ivahaev/amigo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Пример использования (здесь применяется ещё мой простой &lt;a href=&#34;https://github.com/ivahaev/go-logger&#34;&gt;логгер&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
    &amp;quot;github.com/ivahaev/amigo&amp;quot;
    &amp;quot;github.com/ivahaev/go-logger&amp;quot;
)

// Создаем функции-обработчики событий
// amigo.M – это псевдоним для map[string]string
func DeviceStateChangeHandler (m amigo.M) {
    logger.Debug(`Принято событие &amp;quot;DeviceStateChange&amp;quot;`, m)
}

func DefaultHandler (m amigo.M) {
    logger.Debug(&amp;quot;Принято событие&amp;quot;, m)
}


func main() {

    // Подключаемся к астериску.
    // Имя пользователя и пароль являются обязательными параметрами.
    // По умолчанию хост – &amp;quot;127.0.0.1&amp;quot;, порт – &amp;quot;5038&amp;quot;.
    a := amigo.New(&amp;quot;username&amp;quot;, &amp;quot;password&amp;quot;, &amp;quot;host&amp;quot;, &amp;quot;port&amp;quot;)
    a.Connect()


    //Регистрируем обработчик для события &amp;quot;DeviceStateChange&amp;quot;
    a.RegisterHandler(&amp;quot;DeviceStateChange&amp;quot;, DeviceStateChangeHandler)

    // Регистрируем обработчик для всех событий
    a.RegisterDefaultHandler(DefaultHandler)

    // Также можем создать канал для приема всех событий
    // и зарегистрировать его
    c := make(chan map[string]string, 100)
    a.SetEventChannel(c)


    // Проверим, что подключение успешно и отправим запрос &amp;quot;QueueSummary&amp;quot;
    if a.Connected() {
        result, err := a.Action(amigo.M{&amp;quot;Action&amp;quot;: &amp;quot;QueueSummary&amp;quot;, &amp;quot;ActionID&amp;quot;: &amp;quot;Init&amp;quot;})
        // Проверяем на ошибку и обрабатываем результат. Ответ на запрос придёт в соответствующем событии.
        // Ловить его нужно в общем канале, обработчике по умолчанию, либо в специальном обработчике.
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Стоит заметить, что подключение будет автоматически восстанавливаться при обрыве связи.&lt;/p&gt;

&lt;p&gt;В следующий раз расскажу как использовать библиотеку в режиме &lt;strong&gt;ASYNC:AGI&lt;/strong&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Шаблонизатор экселя для Go</title>
      <link>http://ivahaev.ru/post/go-xlsx-templater/</link>
      <pubDate>Mon, 28 Dec 2015 00:05:30 +0500</pubDate>
      
      <guid>http://ivahaev.ru/post/go-xlsx-templater/</guid>
      <description>

&lt;p&gt;В процессе работы над платформой &lt;a href=&#34;http://getblank.net/ru&#34;&gt;Blank&lt;/a&gt;, возникла задача генерации документов. Так как платформа предполагает очень широкое применение, очень не хотелось формировать документы полностью программно. Нужно дать возможность интеграторам и администраторам системы удобно создавать шаблоны, на основе которых, в дальнейшем, будут формироваться различные документы.&lt;/p&gt;

&lt;p&gt;Сервер написан на &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt;, поэтому первым делом я принялся изучать что уже придумано умными людьми для решения подобных задач. Оказалось, что совсем не много. Обсуждения, в основном, скатываются в область&amp;nbsp;&amp;mdash; есть решения на Яве, используйте их.  Неее, не для того мы на &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; пишем, чтобы за собой Яву тянуть.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ivahaev.ru/img/net!.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Также, наш сервер поддерживает пользовательские скрипты на &lt;strong&gt;Javascript&lt;/strong&gt;, но полноценных решений тоже не нашлось.&lt;/p&gt;

&lt;p&gt;Решено было сделать все самостоятельно. &lt;a href=&#34;http://getblank.net/ru&#34;&gt;Blank&lt;/a&gt; вовсю использует &lt;a href=&#34;http://handlebarsjs.com/&#34;&gt;Handlebars&lt;/a&gt;, поэтому захотелось использовать похожее поведение для формирования документов. Первым этапом пошли электронные таблицы, то, что мы привыкли видеть в Excel. Родился пакет &lt;a href=&#34;https://github.com/ivahaev/go-xlsx-templater&#34;&gt;go-xlsx-templater&lt;/a&gt;, которые позволяет разметить документ &lt;strong&gt;Excel&lt;/strong&gt; (&lt;strong&gt;.xlsx&lt;/strong&gt;) тэгами в &amp;laquo;усах&amp;raquo; и получить, в итоге конечный отчет с данными.&lt;/p&gt;

&lt;p&gt;На данный момент, библиотека имеет 4 метода: &lt;code&gt;ReadTemplate()&lt;/code&gt;, &lt;code&gt;Render()&lt;/code&gt;, &lt;code&gt;Save()&lt;/code&gt;, &lt;code&gt;Write()&lt;/code&gt;. Рассмотрим небольшой пример использования.&lt;/p&gt;

&lt;h2 id=&#34;создаем-отчет:3ef4d51230cae7854e1bf19bb065638c&#34;&gt;Создаем отчет&lt;/h2&gt;

&lt;p&gt;Первым делом, нужно создать шаблон документа. У нас есть заголовок с приветствием к пользователю, а так же табличка со списком предметов, находящихся во владении пользователем. Как видим, синтаксис определения снипетов совпадает с &lt;a href=&#34;http://handlebarsjs.com/&#34;&gt;Handlebars&lt;/a&gt; или &lt;a href=&#34;https://mustache.github.io/&#34;&gt;Mustache&lt;/a&gt;. Важно помнить, в данном случае, что при указании снипета с точкой внутри, как в примере &lt;code&gt;{{items.name}}&lt;/code&gt;&amp;nbsp;&amp;mdash; это будет означать либо брать свойство из вложенного объекта в переданном контексте, либо из соответствующего элемента в массиве, при этом будет создано нужное количество строк, чтобы заполнить всеми элементами массива, как в нашем случае.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ivahaev.ru/img/xls-template.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Передаем мы вот что:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	map[string]interface{}{
		&amp;quot;name&amp;quot;:           &amp;quot;Github User&amp;quot;,
		&amp;quot;nameHeader&amp;quot;:     &amp;quot;Item name&amp;quot;,
		&amp;quot;quantityHeader&amp;quot;: &amp;quot;Quantity&amp;quot;,
		&amp;quot;items&amp;quot;: []map[string]interface{}{
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Pen&amp;quot;,
				&amp;quot;quantity&amp;quot;: 2,
			},
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Pencil&amp;quot;,
				&amp;quot;quantity&amp;quot;: 1,
			},
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Condom&amp;quot;,
				&amp;quot;quantity&amp;quot;: 12,
			},
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Beer&amp;quot;,
				&amp;quot;quantity&amp;quot;: 24,
			},
		},
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После обработки получаем долгожданный документ:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ivahaev.ru/img/xls-report.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Файл мы можем либо сохранить на диск, либо сразу отдать в ответ на http запрос, благо, библиотека поддерживает интерфейс &lt;code&gt;io.Writer&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Пакет только что создан, еще толком не протестирован, но зато уже его можно как-то использовать в работе. В дальнейшем буду его развивать и улучшать.&lt;/p&gt;

&lt;p&gt;Полный код демо-приложения выглядит так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;github.com/ivahaev/go-xlsx-templater&amp;quot;
)

func main() {
	doc := xlst.New()
	doc.ReadTemplate(&amp;quot;./template.xlsx&amp;quot;)
	ctx := map[string]interface{}{
		&amp;quot;name&amp;quot;:           &amp;quot;Github User&amp;quot;,
		&amp;quot;nameHeader&amp;quot;:     &amp;quot;Item name&amp;quot;,
		&amp;quot;quantityHeader&amp;quot;: &amp;quot;Quantity&amp;quot;,
		&amp;quot;items&amp;quot;: []map[string]interface{}{
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Pen&amp;quot;,
				&amp;quot;quantity&amp;quot;: 2,
			},
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Pencil&amp;quot;,
				&amp;quot;quantity&amp;quot;: 1,
			},
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Condom&amp;quot;,
				&amp;quot;quantity&amp;quot;: 12,
			},
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Beer&amp;quot;,
				&amp;quot;quantity&amp;quot;: 24,
			},
		},
	}
	doc.Render(ctx)
	doc.Save(&amp;quot;./report.xlsx&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Обработка ошибок здесь не показана, но в реальном приложении, естественно, стоит их учитывать.&lt;/p&gt;

&lt;p&gt;Буду рад любым откликам и предложениям по развитию пакета!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Три частые ошибки, возникающие при разработке на Go</title>
      <link>http://ivahaev.ru/post/three-often-mistakes-wth-go/</link>
      <pubDate>Thu, 12 Nov 2015 01:32:28 +0500</pubDate>
      
      <guid>http://ivahaev.ru/post/three-often-mistakes-wth-go/</guid>
      <description>

&lt;p&gt;Это перевод статьи. Раньше желания переводить не возникало, но статья очень понравилась, наверное, из-за того, что сам наступал уже на подобные грабли. Перевод достаточно вольный, но суть передает верно. Если хоть одному начинающему разработчику поможет эта статья, труды мои будут не напрасными :).&lt;/p&gt;

&lt;p&gt;Оригинал статьи доступен по адресу &lt;a href=&#34;http://bryce.is/writing/code/jekyll/update/2015/11/01/3-go-gotchas.html&#34;&gt;http://bryce.is/writing/code/jekyll/update/2015/11/01/3-go-gotchas.html&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;1-итерация-через-range:09760c5f9427cb3b4e256b9be52ce692&#34;&gt;1. Итерация через range&lt;/h2&gt;

&lt;p&gt;Использовать &lt;code&gt;range&lt;/code&gt; очень удобно. Перебирая срез или отображение, для каждого элемента мы получаем две переменные, в первой индекс элемента, во второй &lt;strong&gt;копия&lt;/strong&gt; значения.
Например:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index, value := range mySlice {
    fmt.Println(&amp;quot;index: &amp;quot; + index)
    fmt.Println(&amp;quot;value: &amp;quot; + value)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Но что же здесь происходит на самом деле? Рассмотрим более подробный пример:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Foo struct {
    bar string
}

func main() {
    list := []Foo{
        {&amp;quot;A&amp;quot;},
        {&amp;quot;B&amp;quot;},
        {&amp;quot;C&amp;quot;},
    }

    list2 := make([]*Foo, len(list))
    for i, value := range list {
        list2[i] = &amp;amp;value
    }

    fmt.Println(list[0], list[1], list[2])
    fmt.Println(list2[0], list2[1], list2[2])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В данном примере происходит следующее:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Создается срез структур &lt;code&gt;Foo&lt;/code&gt; под названием &lt;code&gt;list&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Определяется срез указателей на структуры &lt;code&gt;Foo&lt;/code&gt;, под названием &lt;code&gt;list2&lt;/code&gt; с длиной равной длине массива &lt;code&gt;list&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Перебираем все структуры в срезе &lt;code&gt;list&lt;/code&gt; и присваиваем указатель на структуру соответствующему элементу среза &lt;code&gt;list2&lt;/code&gt; (имеющему тот же индекс);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вероятнее всего, мы ожидаем следующий результат работы вышеприведенного кода:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{A} {B} {C}
&amp;amp;{A} &amp;amp;{B} &amp;amp;{C}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;А на самом деле, получаем:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{A} {B} {C}
&amp;amp;{C} &amp;amp;{C} &amp;amp;{C}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Первая строка именно такая как ожидалась, а вот со второй что-то не так. Как будто бы распечатался указатель на третий элемент среза &lt;code&gt;list2&lt;/code&gt; три раза. Почему же такое произошло?&lt;/p&gt;

&lt;p&gt;Всему виной этот самый удобный &lt;code&gt;range&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i, value := range list {
    list2[i] = &amp;amp;value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go передает &lt;strong&gt;копий&lt;/strong&gt; значений элементов вместо самих значений, когда производится итерация с помощью &lt;code&gt;range&lt;/code&gt;. И когда мы создаем указатель на &lt;code&gt;value&lt;/code&gt;, на самом деле, мы создаем указатель на &lt;strong&gt;копию&lt;/strong&gt; значения. При каждой итерации, копия нового значения помещается в ту же ячейку памяти, что и предыдущее, таким образом, все указатели в срезе &lt;code&gt;list2&lt;/code&gt; приводят к одной области памяти.&lt;/p&gt;

&lt;p&gt;Правильно решить поставленную задачу можно так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var value Foo
for var i := 0; i &amp;lt; len(list); i++ {
    value = list[i]
    list2[i] = &amp;amp;value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Или, все-таки, с помощью &lt;code&gt;range&lt;/code&gt;, но взяв из него только индекс элемента:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i := range list {
    list2[i] = &amp;amp;list[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-использование-встроенной-функций-append:09760c5f9427cb3b4e256b9be52ce692&#34;&gt;2. Использование встроенной функций append&lt;/h2&gt;

&lt;p&gt;Срезы&amp;nbsp;&amp;mdash; один из примитивных типов в Go. То что в других языках делается с массивами, в гоу можно сделать только со срезом.
Например, нам нужно добавить значение в срез элементов типа &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list := []int{0,1,2}
list = append(list, 3)
fmt.Println(list) // [0 1 2 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На первый взгляд, все похоже на метод &lt;code&gt;push()&lt;/code&gt; для массивов в других языках, но срезы&amp;nbsp;&amp;mdash; это не совсем массивы и функция &lt;code&gt;append&lt;/code&gt; иногда может удивить.&lt;/p&gt;

&lt;p&gt;Рассмотрим другой пример:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    a := []byte(&amp;quot;foo&amp;quot;)
    b := append(a, []byte(&amp;quot;bar&amp;quot;)...)
    c := append(a, []byte(&amp;quot;baz&amp;quot;)...)

    fmt.Println(string(a), string(b), string(c))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Здесь мы определили срез байт и сразу же инициировали его, преобразовав в срез строку &lt;strong&gt;&amp;ldquo;foo&amp;rdquo;&lt;/strong&gt;. Далее мы добавляем срез &lt;strong&gt;[&amp;ldquo;bar&amp;rdquo;]&lt;/strong&gt; к первому срезу, присваиваем полученное переменной &lt;code&gt;b&lt;/code&gt;, после чего добавляем другой срез &lt;strong&gt;[&amp;ldquo;baz&amp;rdquo;]&lt;/strong&gt; также к первому срезу и присваиваем полученное переменной &lt;code&gt;c&lt;/code&gt;. Результатом работы данной программы будет следующее:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo foobaz foobaz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://ivahaev.ru/img/shta.jpeg&#34; alt=&#34;Шта?&#34; /&gt;
Какого? Мы-то ждали &lt;code&gt;foo foobar foobaz&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;Чтобы понять что произошло, следует разобраться с тем, а что же за звери такие эти срезы? Срез в Go&amp;nbsp;&amp;mdash; это дексриптор, который содержит три компонента:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Указатель на базовый &lt;strong&gt;массив&lt;/strong&gt; элементов. К этому массиву мы не получим прямого доступа;&lt;/li&gt;
&lt;li&gt;Емкость базового массива;&lt;/li&gt;
&lt;li&gt;Длину среза.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Так что же произошло на самом деле? Go переиспользует базовый массив в функции &lt;code&gt;append&lt;/code&gt; если он может сделать это не изменяя его емкости. Все три переменные в примере указывают на одну и ту же области памяти. Единственная разница, что срез &lt;code&gt;a&lt;/code&gt; имеет длину &lt;strong&gt;3&lt;/strong&gt;, а срезы &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; длину равную 6.&lt;/p&gt;

&lt;p&gt;Следует всегда помнить, что Go будет использовать тот же базовый массив, если длина нового среза будет меньшей или равной емкости изначального среза.&lt;/p&gt;

&lt;h2 id=&#34;3-затенение-переменных:09760c5f9427cb3b4e256b9be52ce692&#34;&gt;3. Затенение переменных&lt;/h2&gt;

&lt;p&gt;Не уверен в переводе термина (&lt;strong&gt;Variable shadowing&lt;/strong&gt;), но примерно как-то так.&lt;/p&gt;

&lt;p&gt;В Go есть один интересный оператор, который выглядит вот так: &lt;code&gt;:=&lt;/code&gt;. Из-за него некоторые говорят, что Go очень похож на Pascal, хотя в Go оператор выполняет несколько другую работу. &lt;code&gt;:=&lt;/code&gt;&amp;nbsp;&amp;mdash; это короткая форма объявления переменной с одновременным присвоением значения и типа, соответствующего переданному значению. Очень удобная форма записи, но, к сожалению, именно она и таит в себе возможность совершить ошибку.&lt;/p&gt;

&lt;p&gt;Рассмотрим следующий код:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    list := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}
    for {
        list, err := repeat(list)
        if err != nil {
            panic(err)
        }
        fmt.Println(list)
        break
    }
    fmt.Println(list)
}

func repeat(list []string) ([]string, error) {
    if len(list) == 0 {
        return nil, errors.New(&amp;quot;Nothing to repeat!&amp;quot;)
    }
    list = append(list, list...)
    return list, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Автор считает, что это очень показательный пример. Ну что же, поверим, к тому же, он вполне себе хорошо иллюстрирует проблему. Происходит следующее:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Создается срез строк с именем &lt;code&gt;list&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Запускается бесконечный цикл;&lt;/li&gt;
&lt;li&gt;Вызываем функцию &lt;code&gt;repeat()&lt;/code&gt;, которая возвращает новый срез и ошибку;&lt;/li&gt;
&lt;li&gt;Прерываем цикл;&lt;/li&gt;
&lt;li&gt;Печатаем &lt;code&gt;list&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Глядя на код, ожидается следующий вывод:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[a b c a b c]
[a b c a b c]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Но на деле получаем:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[a b c a b c]
[a b c]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;А все потому, что когда использовали оператор &lt;code&gt;:=&lt;/code&gt;, мы на самом деле определили новую переменную &lt;code&gt;list&lt;/code&gt; в области видимости цикла. В Go фигурные скобки создают новую область видимости. Мы это сделали для того, чтобы быстренько объявить переменную &lt;code&gt;err&lt;/code&gt; типа &lt;code&gt;error&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://ivahaev.ru/img/norma.jpeg&#34; alt=&#34;Это норма&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Чтобы исправить ситуацию, нужно объявить &lt;code&gt;err&lt;/code&gt; заранее и далее использовать обычный оператор присваивания &lt;code&gt;=&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var err error
list, err = duplicate(list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В поставке Go есть отличная утилита &lt;code&gt;go vet&lt;/code&gt;, запустив которую с опцией &lt;code&gt;-shadow&lt;/code&gt;, можно проверить код на наличие потенциальных ошибок связанных с затенением переменных.&lt;/p&gt;

&lt;p&gt;Go&amp;nbsp;&amp;mdash; отличный язык, но чтобы создавать действительно классно работающие приложения, стоит понимать что происходит у него &amp;ldquo;под капотом&amp;rdquo;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>