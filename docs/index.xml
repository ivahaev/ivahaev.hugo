<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ivahaev.ru</title>
    <link>https://ivahaev.ru/index.xml</link>
    <description>Recent content on ivahaev.ru</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru-RU</language>
    <copyright>2016 Евгений Иваха</copyright>
    <lastBuildDate>Wed, 13 Jul 2016 11:28:50 +0500</lastBuildDate>
    <atom:link href="https://ivahaev.ru/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Двойной API для асинхронных функций</title>
      <link>https://ivahaev.ru/post/javascript-callback-promise-dual-api/</link>
      <pubDate>Wed, 13 Jul 2016 11:28:50 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/javascript-callback-promise-dual-api/</guid>
      <description>&lt;p&gt;Когда пишешь публичные асинхронные методы на &lt;strong&gt;JavaScript&lt;/strong&gt;, желательно придерживаться двух простых правил:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Если метод может вернуть ошибку в колбэке, то ошибка должна идти первым аргументом. Часто, даже если метод никогда не возвращает ошибку, первым аргументом передают &lt;code&gt;null&lt;/code&gt; для того, чтобы унифицировать все асинхронные вызовы;&lt;/li&gt;
&lt;li&gt;Если в метод не передана колбэк-функция, то метод должен вернуть Promise.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Если с первым правилом все достаточно просто, то для удобного выполнения второго, в нашей команде родилось короткое однострочное выражение, которые мы повсеместно используем:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Javascript&#34;&gt;let d = (typeof cb !== &amp;quot;function&amp;quot;) ? new Promise((f, r) =&amp;gt; (cb = (e, d) =&amp;gt; e != null ? r(e) : f(d))) : null;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Покажу, как водится, на примере таймера:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Javascript&#34;&gt;var asyncMethod = (timeOut, cb) {
    // Если cb не является функцией, создаем Promise и модифицируем cb для использования далее.
    let d = (typeof cb !== &amp;quot;function&amp;quot;) ? new Promise((f, r) =&amp;gt; (cb = (e, d) =&amp;gt; e != null ? r(e) : f(d))) : null;

    // Используем cb как обычный колбэк
    setTimeout(cb, timeOut);

    // Возвращаем либо Promise, если колбэка не было, либо null
    return d;
};

// Используем в классическом стиле:
asyncMethod(1000, () =&amp;gt; {
    console.log(&amp;quot;Classic timeout reached!&amp;quot;);
});

// Используем через Promise
asyncMethod(1000).then(() =&amp;gt; console.log(&amp;quot;Promise timeout reached!&amp;quot;));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Таким вот простым способом, можно улучшить публичный API в части асинхронных методов.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Мой подход к тестированию. Часть первая</title>
      <link>https://ivahaev.ru/post/how-to-test-go-applications-my-way-part-one/</link>
      <pubDate>Fri, 08 Jul 2016 03:11:50 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/how-to-test-go-applications-my-way-part-one/</guid>
      <description>&lt;p&gt;Сколько бы &amp;laquo;в прошлой жизни&amp;raquo; я не пытался заставить себя писать тесты, получалось довольно плохо. Точнее, оно получалось, но как-то всё хромало, как у Винни-Пуха правильнописание. Казалось, что быстрее и проще потыкать в браузере, или клавиши понажимать, проверить, а дальше просто будет работать.&lt;/p&gt;

&lt;p&gt;По мере усложнения создаваемых приложений, логика становилась всё замудрённее, времени на такое вот &amp;laquo;протыкивание&amp;raquo; стало уходить всё больше. Каким-то своим отдельным путём я пришёл к тому, что стал писать мелкие отдельные файлы, которые выполняли некоторые функции из проекта и проверяли вывод на корректность. Таким образом, я для себя открыл юнит тестирование. Проблема была в том, что тесты необходимо поддерживать в актуальном состоянии, модифицировать вместе с основным кодом, а ведь кажется, что есть гораздо более важные задачи на данный момент.&lt;/p&gt;

&lt;p&gt;В мае 2016 года было принято решение начать писать тесты в принудительном порядке, тем более, что исходные тексты новой версии нашей платформы &lt;a href=&#34;https://github.com/getblank&#34;&gt;Blank&lt;/a&gt; мы открыли сразу, а в грязь лицом ударить не хотелось.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h3 id=&#34;node-js&#34;&gt;Node.js&lt;/h3&gt;

&lt;p&gt;С подсистемой на &lt;a href=&#34;https://nodejs.org&#34;&gt;Node.js&lt;/a&gt; вопросов никаких не возникло. Есть популярное решения для тестирования&amp;nbsp;&amp;mdash; &lt;a href=&#34;mochajs.org&#34;&gt;Mocha&lt;/a&gt; (по-русски лучше не читать :) с понятным синтаксисом и весьма приятным форматированием результатов тестирования. Ну и, конечно, стандартный модуль &lt;a href=&#34;https://nodejs.org/api/assert.html&#34;&gt;Assert&lt;/a&gt; для выполнения проверок.&lt;/p&gt;

&lt;h3 id=&#34;go&#34;&gt;Go&lt;/h3&gt;

&lt;p&gt;С &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; ситуация несколько иная. Стандартная поставка уже имеет средства для оформления и запуска тестов. Я сейчас говорю о пакете &lt;a href=&#34;https://golang.org/pkg/testing/&#34;&gt;testing&lt;/a&gt;, в котором есть даже средства для замера производительности кода. Всё, что требуется&amp;nbsp;&amp;mdash; это создать рядом с тестируемым кодом файл с именем, &lt;em&gt;оканчивающимся&lt;/em&gt; на &lt;code&gt;_test.go&lt;/code&gt;, например, &lt;code&gt;app_test.go&lt;/code&gt;, а в нем должны быть функции, &lt;em&gt;начинающиеся&lt;/em&gt; на &lt;code&gt;Test&lt;/code&gt; и получающие на вход указатель на структуру &lt;code&gt;testing.T&lt;/code&gt;, с помощью методов которой можно, например, &amp;laquo;завалить&amp;raquo; тест. Во время компилляции, такие файлы игнорируются.&lt;/p&gt;

&lt;p&gt;Например, у нас есть пакет с единственным методом, складывающим два положительных целых числа. В случае, если одно из чисел окажется отрицательным, функция возвращает ошибку. Понятно, что в реальной жизни программы должны делать что-то более полезное, но для объяснения сути, так даже понятнее:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// adder.go
package adder

import &amp;quot;errors&amp;quot;

func AddPositive(a, b int) (int, error) {
    if a &amp;lt; 0 || b &amp;lt; 0 {
        return 0, errors.New(&amp;quot;only positive integers allowed&amp;quot;)
    }
    return a + b, nil
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Напишем тесты:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// adder_test.go
package adder

import &amp;quot;testing&amp;quot;

func TestAddPositiveSuccess(t *testing.T) {
	expected := 5
	res, err := AddPositive(2, 3)
	if err != nil {
		t.Fatal(err)
	}
	if res != expected {
		t.Fatal(&amp;quot;Achtung! value != expected&amp;quot;)
	}
}

func TestAddPositiveFail(t *testing.T) {
	_, err := AddPositive(2, -3)
	if err == nil {
		t.Fatal(&amp;quot;must return error&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В общем случае, чтобы запустить тестирование, достаточно выполнить команду &lt;code&gt;go test&lt;/code&gt;. Если все работает правильно, мы увидим нечто вроде &lt;strong&gt;PASS&lt;/strong&gt; в консоли, что означает, что тесты выполнились успешно.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-3.2$ go test
PASS
ok  	_/tmp/adder	0.018s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Не очень-то информативно.&lt;/p&gt;

&lt;p&gt;Вроде бы, никаких проблем, тест читаемый&amp;nbsp;&amp;mdash; если произошла ошибка, или результат выполнения функции не тот, что ожидали, то всё плохо. Смысл теста можно вложить в название тест-функции. Если тест будет завален, то в консоль будет выведена функция, в которой не прошли проверки и строка с соответствующей инструкцией &lt;code&gt;t.Fatal&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-3.2$ go test
--- FAIL: TestAddPositiveFail (0.00s)
	adder_test.go:19: must return error
FAIL
exit status 1
FAIL	_/tmp/adder	0.009s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Но после  &lt;strong&gt;Mocha&lt;/strong&gt; хочется какого-то бо&amp;#769;льшего удовлетворения. Чтобы красиво вывести все проверки. Чтобы можно было подробнее описать что именно тестируем и почему такой-то результат ожидаем.&lt;/p&gt;

&lt;h3 id=&#34;goblin&#34;&gt;Goblin&lt;/h3&gt;

&lt;p&gt;Поиск инструмента я начал с ресурса &lt;a href=&#34;https://github.com/avelino/awesome-go&#34;&gt;Awesome Go&lt;/a&gt;, там вообще много чего интересного можно найти, а иногда даже и полезного. Перебрал кучу тестирующих фреймворков, пока не дошёл до &lt;a href=&#34;https://github.com/franela/goblin&#34;&gt;Гоблина&lt;/a&gt;. Т.к. мы договорились не называть по-русски другой фреймворк, то скажу дословно, как рассказывают о Гоблине его содатели:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A Mocha like BDD testing framework for Go&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;То, что доктор прописал!&lt;/p&gt;

&lt;p&gt;Перепишем наш тест с использованием Гоблина:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package adder

import (
	&amp;quot;github.com/franela/goblin&amp;quot;
	&amp;quot;testing&amp;quot;
)

func TestAddPositive(t *testing.T) {
	g := goblin.Goblin(t)

	g.Describe(&amp;quot;#AddPositive&amp;quot;, func() {
		g.It(&amp;quot;should return nil error and expected result when positive integer passed&amp;quot;, func() {
			expected := 5
			res, err := AddPositive(2, 3)
			g.Assert(err == nil).IsTrue()
			g.Assert(res).Equal(expected)
		})

		g.It(&amp;quot;should return error when negative integer passed&amp;quot;, func() {
			_, err := AddPositive(2, -3)
			g.Assert(err == nil).IsFalse()
		})
	})
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;А теперь посмотрим на вывод команды &lt;code&gt;go test&lt;/code&gt; в консоли:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;bash-3.2$ go test

  #AddPositive
    ✔ should return nil error and expected result when positiv integer passed
    ✔ should return error when negative integer passed


 2 tests complete (0 ms)
PASS
ok  	_/tmp/adder	0.008s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На мой взгляд, гораздо приятнее. При этом ещё и красиво цветом выделяются пройдённые тесты. Что тест, что вывод в консоли говорит сам за себя&amp;nbsp;&amp;mdash; тестируем функцию &lt;code&gt;AddPositive&lt;/code&gt;, которая должна выполниться без ошибки и вернуть ожидаемый результат, если на вход подаются положительные значения, а так же должна вернуть ошибку, если на вход подали что-то отрицательное.&lt;/p&gt;

&lt;p&gt;Попробовав один раз, использую теперь Гоблина во всех проектах, я им очень доволен. При этом, Гоблин полностью совместим со стандартной библиотекой testing.&lt;/p&gt;

&lt;h3 id=&#34;goconvey&#34;&gt;GoConvey&lt;/h3&gt;

&lt;p&gt;А теперь ещё один секрет. Есть довольно интересная штука, которая называется &lt;a href=&#34;http://goconvey.co/&#34;&gt;GoConvey&lt;/a&gt;. Это тоже фреймворк для тестирования, но с несколько другой идеологией, которая мне не очень понравилась. Зато мне понравилось как GoConvey работает в связке с Гоблином. Установив программу, запускаем в корне проекта. GoConvey сам откроет браузер, где мы сможем наблюдать вот такую красоту:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ivahaev.ru/img/goconvey_success800.png&#34; alt=&#34;output&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Он сам запустит тесты во всех сабмодулях, выведет суммарный отчет, покажет степень покрытия кода тестами (у нас 100% покрытие, как мы видим :). При этом будет перезапускать тесты при каждом изменении исходного кода и тут же отображать результат в браузере. Это просто праздник какой-то!&lt;/p&gt;

&lt;p&gt;С самостоятельным тестированием разобрались. В следующей статье расскажу, как тестировать проекты принудительно. Не переключайтесь!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Версионирование go программ</title>
      <link>https://ivahaev.ru/post/go-releases-versions/</link>
      <pubDate>Fri, 01 Jul 2016 23:11:50 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/go-releases-versions/</guid>
      <description>&lt;p&gt;Читая новости &lt;a href=&#34;http://4gophers.ru/&#34;&gt;на отличном ресурсе по Go&lt;/a&gt;, наткнулся на статью Дейва Чени &lt;a href=&#34;http://dave.cheney.net/2016/06/24/gophers-please-tag-your-releases&#34;&gt;Гоферы, тэгируйте свои релизы&lt;/a&gt;. Вкратце, там говорится о полезности тэгов к комитам пакета в git репозитории, а так же о том, что при указании версии, стоит обратить внимание на формат &lt;a href=&#34;http://semver.org/spec/v2.0.0.html&#34;&gt;SemVer 2.0.0&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Что самое интересное, статья написана 24 июня, примерно в то же время, может быть, днём ранее, я написал инструмент для себя, который позволяет автоматизировать процесс изменения патч-версии приложений, написанных на &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Вдохновил меня на этот поступок, как ни странно, инструмент из мира &lt;a href=&#34;https://nodejs.org&#34;&gt;node.js&lt;/a&gt;&amp;nbsp;&amp;mdash; &lt;a href=&#34;https://www.npmjs.com/&#34;&gt;npm&lt;/a&gt;. Дело в том, что &lt;strong&gt;npm&lt;/strong&gt; имеет в своём арсенале команду &lt;code&gt;version patch&lt;/code&gt;, которая делает три простые и очень нужные вещи для npm пакетов:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Увеличивает на единичку в файле &lt;strong&gt;package.json&lt;/strong&gt; версию патча, согласно &lt;a href=&#34;http://semver.org/spec/v2.0.0.html&#34;&gt;SemVer 2.0.0&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;Комитит файла &lt;strong&gt;package.json&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;Навешивает на комит тэг, соответствующий версии в &lt;strong&gt;package.json&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;В нашем главном проекте &lt;a href=&#34;http://getblank.net&#34;&gt;Blank&lt;/a&gt;, в npm пакетах, мы дописали скрипты в файл &lt;strong&gt;package.json&lt;/strong&gt; для автоматической заливки изменений на &lt;a href=&#34;https://github.com/&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-JSON&#34;&gt;  &amp;quot;scripts&amp;quot;: {
    &amp;quot;patch&amp;quot;: &amp;quot;npm version patch &amp;amp;&amp;amp; npm run push&amp;quot;,
    &amp;quot;push&amp;quot;: &amp;quot;git push origin master --follow-tags &amp;amp;&amp;amp; npm publish&amp;quot;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Таким образом, для того, чтобы &amp;laquo;зарелизить&amp;raquo; новую патч-версию своего приложения, достаточно написать в корне проекта:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; npm run patch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;NPM остальное сделает сам&amp;nbsp;&amp;mdash; увеличит версию патча, сделает комит, навесит тэг с версией и отправит на github.&lt;/p&gt;

&lt;p&gt;Мне эта штука так понравилась, что, не найдя ничего похожего для &lt;strong&gt;Go&lt;/strong&gt;, я решил сделать подобный инструмент для гоферов. Итак, представляю &lt;a href=&#34;https://github.com/ivahaev/patcher&#34;&gt;patcher&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Что он делает:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;В файле &lt;strong&gt;main.go&lt;/strong&gt; в корне проекта ищет переменную &lt;strong&gt;version&lt;/strong&gt; и увеличивает на единицу патч-версию;&lt;/li&gt;
&lt;li&gt;Комитит файл &lt;strong&gt;main.go&lt;/strong&gt; с сообщением &lt;strong&gt;Version update: ЗНАЧЕНИЕ_ПЕРЕМЕННОЙ_version&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;Навешивает к комиту тэг &lt;strong&gt;vЗНАЧЕНИЕ_ПЕРЕМЕННОЙ_version&lt;/strong&gt;;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Кроме того, при запуске с ключом &lt;strong&gt;-p&lt;/strong&gt; (&lt;code&gt;patcher -p&lt;/code&gt;), утилита тут же отправит все изменения в удалённый репозиторий. Вот так всё просто.&lt;/p&gt;

&lt;p&gt;Далее уже можно настроить систему непрерывной интеграции, например, на сборку тэгированных релизов с автоматическим обновлением сервисов, либо с публикацией на ресурсах для скачивания приложения.&lt;/p&gt;

&lt;p&gt;Установка производится как обычно:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; go get github.com/ivahaev/patcher
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Если &lt;code&gt;$GOPATH/bin&lt;/code&gt; находится в вашем &lt;code&gt;$PATH&lt;/code&gt;, запуск производится из командной строки&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; patcher [filename [varName]] [-p]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Или если в &lt;code&gt;$PATH&lt;/code&gt; не прописаны пути:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; $GOPATH/bin/patcher [filename [varName]] [-p]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Есть два необязательных параметра&amp;nbsp;&amp;mdash; имя файла, в котором находится переменная с версией и, имя самой переменной с версией приложения. По-умолчанию, эти параметры равны &lt;strong&gt;main.go&lt;/strong&gt; и &lt;strong&gt;version&lt;/strong&gt;, соответственно. Также, если указать ключ &lt;strong&gt;-p&lt;/strong&gt;, утилита автоматически отправит изменения в удалённый репозиторий.&lt;/p&gt;

&lt;p&gt;Я использую эту утилиту каждый день и она делает мою жизнь гораздо ярче, чего и вам желаю :).&lt;/p&gt;

&lt;p&gt;В другой раз расскажу о том, как всё это используется для непрерывной интеграции в наших проектах.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Прокаченный таймер на Go</title>
      <link>https://ivahaev.ru/post/advanced-go-timer/</link>
      <pubDate>Sun, 01 May 2016 14:12:32 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/advanced-go-timer/</guid>
      <description>&lt;p&gt;У языка &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; шикарная стандартная библиотека, инструменты на все случаи жизни, при этом достаточно лаконичные. Например, рассмотрим отличный пакет &lt;a href=&#34;https://golang.org/pkg/time/&#34;&gt;time&lt;/a&gt;. За всё время работы с &lt;strong&gt;Go&lt;/strong&gt;, мне всего лишь дважды приходилось расширять его возможности.&lt;/p&gt;

&lt;p&gt;Первый раз, около года назад, понадобилось строковое представление времени и периодов на русском языке, что привело к созданию пакета &lt;a href=&#34;https://github.com/ivahaev/russian-time&#34;&gt;russian-time&lt;/a&gt;. Он не очень красивый, создан на скорую руку, потому не буду на нём останавливаться.&lt;/p&gt;

&lt;p&gt;Второй инструмент мне кажется более интересным. Предпосылкой к созданию этого небольшого пакета, была необходимость контроля времени выполнения скриптов во встроенном интерпретаторе &lt;strong&gt;JavaScript&lt;/strong&gt; &lt;strong&gt;Google V8&lt;/strong&gt;. Так уж повелось, что &lt;strong&gt;JavaScript&lt;/strong&gt;, как правило, характеризуется асинхронным поведением, что несколько затрудняло выполнение поставленной задачи. Одним из компонентов решения должен был стать таймер, который можно приостанавливать на неопределённое время, а после запускать снова с момента остановки. Так появился &lt;a href=&#34;https://github.com/ivahaev/timer&#34;&gt;timer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Функции &lt;a href=&#34;https://godoc.org/github.com/ivahaev/timer#AfterFunc&#34;&gt;AfterFunc&lt;/a&gt;  и &lt;a href=&#34;https://godoc.org/github.com/ivahaev/timer#NewTimer&#34;&gt;NewTimer&lt;/a&gt;  очень похожи на стандартные, но у возвращаемого указателя на структуру &lt;a href=&#34;https://godoc.org/github.com/ivahaev/timer#Timer&#34;&gt;Timer&lt;/a&gt; есть два новых метода:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/ivahaev/timer#Timer.Pause&#34;&gt;Pause&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://godoc.org/github.com/ivahaev/timer#Timer.Start&#34;&gt;Start&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Pause&lt;/strong&gt; приостанавливает выполнение таймера, а &lt;strong&gt;Start&lt;/strong&gt;, соответственно, запускает его с момента остановки, либо после инициализации. Т.е. после создания таймера, запускать его требуется вручную.&lt;/p&gt;

&lt;p&gt;Пример из теста лучше покажет идею:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var now = time.Now()

// Создаем таймер на 1 секунду
var timer = AfterFunc(time.Second, func() {

    // Сравниваем сколько прошло времени
	if time.Now().Sub(now) &amp;lt; time.Second*2 {
		panic(&amp;quot;Early func&amp;quot;)
	}
})

// Запускаем таймер
timer.Start()

// Через полсекунды приостанавливаем
time.Sleep(time.Microsecond * 500)
timer.Pause()

// Через секунду запускаем снова
time.Sleep(time.Second)
timer.Start()
time.Sleep(time.Second)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://godoc.org/github.com/ivahaev/timer&#34;&gt;&lt;img src=&#34;https://godoc.org/github.com/ivahaev/timer?status.svg&#34; alt=&#34;GoDoc&#34; /&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>go-logger – простой и информативный логгер для Go</title>
      <link>https://ivahaev.ru/post/simple-logger-for-golang/</link>
      <pubDate>Mon, 18 Jan 2016 00:47:11 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/simple-logger-for-golang/</guid>
      <description>&lt;p&gt;Не смотря на всё многообразие существующих логгеров для &lt;strong&gt;Go&lt;/strong&gt;, как-то не удалось подобрать удобный и подходящий для меня. Хотелось иметь инструмент, похожий на те, какими пользовался в других языках. Если хочешь сделать что-то хорошо, сделай это сам.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update 3 августа 2016 года.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Здесь имеется ввиду логирование какой-то информации в консоль, либо файл. Случай со структурированными логами рассматривается в конце статьи.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Итак, мой &lt;a href=&#34;https://github.com/ivahaev/go-logger&#34;&gt;go-logger&lt;/a&gt;. Что он умеет и чем он лучше других:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Все методы логгирования принимают любое количество аргументов любых типов;&lt;/li&gt;
&lt;li&gt;Метод &lt;a href=&#34;https://godoc.org/github.com/ivahaev/go-logger#Debug&#34;&gt;Debug()&lt;/a&gt; красиво выводит данные. Если это структура, слайс или мапа, то будет наглядно видно что в них, если же это простая переменная, то увидим тип и размер;&lt;/li&gt;
&lt;li&gt;Отображается файл и строка в которой вызвано логгирование;&lt;/li&gt;
&lt;li&gt;Цветовое кодирование каждого уровня;&lt;/li&gt;
&lt;li&gt;Возможность изменить формат вывода даты.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;пример&#34;&gt;Пример&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;    package main

    import &amp;quot;github.com/ivahaev/go-logger&amp;quot;

    func main() {
        logger.SetLevel(&amp;quot;DEBUG&amp;quot;)

        logger.Debug(&amp;quot;Some string for debug&amp;quot;, 123, map[string]interface{}{&amp;quot;prop1&amp;quot;: &amp;quot;val1&amp;quot;, &amp;quot;prop2&amp;quot;: 321})
        logger.Info(&amp;quot;Some string for info&amp;quot;, 123, map[string]interface{}{&amp;quot;prop1&amp;quot;: &amp;quot;val1&amp;quot;, &amp;quot;prop2&amp;quot;: 321})
        logger.Notice(&amp;quot;Some string for debug&amp;quot;, 123, map[string]interface{}{&amp;quot;prop1&amp;quot;: &amp;quot;val1&amp;quot;, &amp;quot;prop2&amp;quot;: 321})
        logger.Warn(&amp;quot;Some string for warning&amp;quot;, 123, map[string]interface{}{&amp;quot;prop1&amp;quot;: &amp;quot;val1&amp;quot;, &amp;quot;prop2&amp;quot;: 321})
        logger.Error(&amp;quot;Some string for error&amp;quot;, 123, map[string]interface{}{&amp;quot;prop1&amp;quot;: &amp;quot;val1&amp;quot;, &amp;quot;prop2&amp;quot;: 321})
        logger.Crit(&amp;quot;Some string for critical&amp;quot;, 123, map[string]interface{}{&amp;quot;prop1&amp;quot;: &amp;quot;val1&amp;quot;, &amp;quot;prop2&amp;quot;: 321})
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Вот что получим в консоли:
&lt;img src=&#34;https://ivahaev.ru/img/logger-console.png&#34; alt=&#34;output&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Со временем добавлю возможность прятать файл вызова и строку, такие мысли уже посещали для продакшина. Может быть, что-то ещё, но пока этот логгер меня устраивает на 100%, я его использую во всех своих проектах. Возможно, пригодится и вам!&lt;/p&gt;

&lt;h4 id=&#34;p-s-3-августа-2016-года&#34;&gt;P.S. 3 августа 2016 года.&lt;/h4&gt;

&lt;p&gt;В данный момент полностью перешёл на &lt;a href=&#34;https://github.com/Sirupsen/logrus&#34;&gt;logrus&lt;/a&gt;, т.к. стал использовать аггрегирование логов в &lt;a href=&#34;https://www.graylog.org/&#34;&gt;Graylog2&lt;/a&gt;, и он здесь удобнее, я оценил всю прелесть структурированных логов. Свой же логгер использую для дебага в процессе разработки, в основном, метод &lt;a href=&#34;https://godoc.org/github.com/ivahaev/go-logger#Debug&#34;&gt;Debug()&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Amigo – лучший друг Golang и Asterisk</title>
      <link>https://ivahaev.ru/post/amigo-best-frend-of-golang-and-asterisk/</link>
      <pubDate>Thu, 14 Jan 2016 21:52:24 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/amigo-best-frend-of-golang-and-asterisk/</guid>
      <description>&lt;p&gt;Начиная писать свой первый &lt;a href=&#34;http://peach-dialer.com&#34;&gt;Peach Dialer&lt;/a&gt;, я выбрал язык, который довольно хорошо знал, благо работал с ним с 1999 года&amp;nbsp;&amp;mdash; &lt;strong&gt;PHP&lt;/strong&gt;. Меня не смущало, что он, в принципе, не предназначен для создания долгоживущих процессов, но то, что получилось в итоге, работает по несколько месяцев и радует своих владельцев.&lt;/p&gt;

&lt;p&gt;Потом пошла мода на &lt;a href=&#34;https://ru.wikipedia.org/wiki/WebSocket&#34;&gt;Websocket&lt;/a&gt;, который захотелось применить в интерфейсе, а &lt;strong&gt;PHP&lt;/strong&gt; в то время не очень-то умел с ними работать (может, и сейчас не умеет). Я обратил внимание на &lt;a href=&#34;https://nodejs.org&#34;&gt;node.js&lt;/a&gt;. Классная штука, любовь на века, подумал я, но вскоре захотелось большего.&lt;/p&gt;

&lt;p&gt;Бо&amp;#769;льшим для меня стал &lt;a href=&#34;https://golang.org&#34;&gt;Go&lt;/a&gt;&amp;nbsp;&amp;mdash; язык, совмещающий скорость и удобство деплоя компилируемых языков с простотой разработки, свойственной интерпретируемым языкам. К сожалению, разработанных библиотек надлежащего качества и с ожидаемым функционалом для взаимодействия с &lt;strong&gt;Asterisk&lt;/strong&gt; в то время не было. Были какие-то начинания, но не доведённые до конца.&lt;/p&gt;

&lt;p&gt;Итак, по сусекам поскребя, да по амбару пометя&amp;#769;, испёк я &lt;a href=&#34;https://github.com/ivahaev/amigo&#34;&gt;Amigo&lt;/a&gt;&amp;nbsp;&amp;mdash; удобную библиотеку для работы с астериском посредством AMI протокола.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Установка библиотеки:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;go get github.com/ivahaev/amigo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Пример использования (здесь применяется ещё мой простой &lt;a href=&#34;https://github.com/ivahaev/go-logger&#34;&gt;логгер&lt;/a&gt;):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (
    &amp;quot;github.com/ivahaev/amigo&amp;quot;
    &amp;quot;github.com/ivahaev/go-logger&amp;quot;
)

// Создаем функции-обработчики событий
// amigo.M – это псевдоним для map[string]string
func DeviceStateChangeHandler (m amigo.M) {
    logger.Debug(`Принято событие &amp;quot;DeviceStateChange&amp;quot;`, m)
}

func DefaultHandler (m amigo.M) {
    logger.Debug(&amp;quot;Принято событие&amp;quot;, m)
}


func main() {

    // Подключаемся к астериску.
    // Имя пользователя и пароль являются обязательными параметрами.
    // По умолчанию хост – &amp;quot;127.0.0.1&amp;quot;, порт – &amp;quot;5038&amp;quot;.
    a := amigo.New(&amp;quot;username&amp;quot;, &amp;quot;password&amp;quot;, &amp;quot;host&amp;quot;, &amp;quot;port&amp;quot;)
    a.Connect()


    //Регистрируем обработчик для события &amp;quot;DeviceStateChange&amp;quot;
    a.RegisterHandler(&amp;quot;DeviceStateChange&amp;quot;, DeviceStateChangeHandler)

    // Регистрируем обработчик для всех событий
    a.RegisterDefaultHandler(DefaultHandler)

    // Также можем создать канал для приема всех событий
    // и зарегистрировать его
    c := make(chan map[string]string, 100)
    a.SetEventChannel(c)


    // Проверим, что подключение успешно и отправим запрос &amp;quot;QueueSummary&amp;quot;
    if a.Connected() {
        result, err := a.Action(amigo.M{&amp;quot;Action&amp;quot;: &amp;quot;QueueSummary&amp;quot;, &amp;quot;ActionID&amp;quot;: &amp;quot;Init&amp;quot;})
        // Проверяем на ошибку и обрабатываем результат. Ответ на запрос придёт в соответствующем событии.
        // Ловить его нужно в общем канале, обработчике по умолчанию, либо в специальном обработчике.
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Стоит заметить, что подключение будет автоматически восстанавливаться при обрыве связи.&lt;/p&gt;

&lt;p&gt;В следующий раз расскажу как использовать библиотеку в режиме &lt;strong&gt;ASYNC:AGI&lt;/strong&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Шаблонизатор экселя для Go</title>
      <link>https://ivahaev.ru/post/go-xlsx-templater/</link>
      <pubDate>Mon, 28 Dec 2015 00:05:30 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/go-xlsx-templater/</guid>
      <description>&lt;p&gt;В процессе работы над платформой &lt;a href=&#34;http://getblank.net/ru&#34;&gt;Blank&lt;/a&gt;, возникла задача генерации документов. Так как платформа предполагает очень широкое применение, очень не хотелось формировать документы полностью программно. Нужно дать возможность интеграторам и администраторам системы удобно создавать шаблоны, на основе которых, в дальнейшем, будут формироваться различные документы.&lt;/p&gt;

&lt;p&gt;Сервер написан на &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt;, поэтому первым делом я принялся изучать что уже придумано умными людьми для решения подобных задач. Оказалось, что совсем не много. Обсуждения, в основном, скатываются в область&amp;nbsp;&amp;mdash; есть решения на Яве, используйте их.  Неее, не для того мы на &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; пишем, чтобы за собой Яву тянуть.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ivahaev.ru/img/net!.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Также, наш сервер поддерживает пользовательские скрипты на &lt;strong&gt;Javascript&lt;/strong&gt;, но полноценных решений тоже не нашлось.&lt;/p&gt;

&lt;p&gt;Решено было сделать все самостоятельно. &lt;a href=&#34;http://getblank.net/ru&#34;&gt;Blank&lt;/a&gt; вовсю использует &lt;a href=&#34;http://handlebarsjs.com/&#34;&gt;Handlebars&lt;/a&gt;, поэтому захотелось использовать похожее поведение для формирования документов. Первым этапом пошли электронные таблицы, то, что мы привыкли видеть в Excel. Родился пакет &lt;a href=&#34;https://github.com/ivahaev/go-xlsx-templater&#34;&gt;go-xlsx-templater&lt;/a&gt;, которые позволяет разметить документ &lt;strong&gt;Excel&lt;/strong&gt; (&lt;strong&gt;.xlsx&lt;/strong&gt;) тэгами в &amp;laquo;усах&amp;raquo; и получить, в итоге конечный отчет с данными.&lt;/p&gt;

&lt;p&gt;На данный момент, библиотека имеет 4 метода: &lt;code&gt;ReadTemplate()&lt;/code&gt;, &lt;code&gt;Render()&lt;/code&gt;, &lt;code&gt;Save()&lt;/code&gt;, &lt;code&gt;Write()&lt;/code&gt;. Рассмотрим небольшой пример использования.&lt;/p&gt;

&lt;h2 id=&#34;создаем-отчет&#34;&gt;Создаем отчет&lt;/h2&gt;

&lt;p&gt;Первым делом, нужно создать шаблон документа. У нас есть заголовок с приветствием к пользователю, а так же табличка со списком предметов, находящихся во владении пользователем. Как видим, синтаксис определения снипетов совпадает с &lt;a href=&#34;http://handlebarsjs.com/&#34;&gt;Handlebars&lt;/a&gt; или &lt;a href=&#34;https://mustache.github.io/&#34;&gt;Mustache&lt;/a&gt;. Важно помнить, в данном случае, что при указании снипета с точкой внутри, как в примере &lt;code&gt;{{items.name}}&lt;/code&gt;&amp;nbsp;&amp;mdash; это будет означать либо брать свойство из вложенного объекта в переданном контексте, либо из соответствующего элемента в массиве, при этом будет создано нужное количество строк, чтобы заполнить всеми элементами массива, как в нашем случае.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ivahaev.ru/img/xls-template.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Передаем мы вот что:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	map[string]interface{}{
		&amp;quot;name&amp;quot;:           &amp;quot;Github User&amp;quot;,
		&amp;quot;nameHeader&amp;quot;:     &amp;quot;Item name&amp;quot;,
		&amp;quot;quantityHeader&amp;quot;: &amp;quot;Quantity&amp;quot;,
		&amp;quot;items&amp;quot;: []map[string]interface{}{
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Pen&amp;quot;,
				&amp;quot;quantity&amp;quot;: 2,
			},
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Pencil&amp;quot;,
				&amp;quot;quantity&amp;quot;: 1,
			},
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Condom&amp;quot;,
				&amp;quot;quantity&amp;quot;: 12,
			},
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Beer&amp;quot;,
				&amp;quot;quantity&amp;quot;: 24,
			},
		},
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;После обработки получаем долгожданный документ:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ivahaev.ru/img/xls-report.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Файл мы можем либо сохранить на диск, либо сразу отдать в ответ на http запрос, благо, библиотека поддерживает интерфейс &lt;code&gt;io.Writer&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Пакет только что создан, еще толком не протестирован, но зато уже его можно как-то использовать в работе. В дальнейшем буду его развивать и улучшать. &lt;em&gt;(Дополнение от 13 июля 2016 года: пакет с марта месяца используется для генерации различных отчетов в одном из подразделений Министерства транспорта РФ и показывает себя только с лучшей стороны)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Полный код демо-приложения выглядит так:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;github.com/ivahaev/go-xlsx-templater&amp;quot;
)

func main() {
	doc := xlst.New()
	doc.ReadTemplate(&amp;quot;./template.xlsx&amp;quot;)
	ctx := map[string]interface{}{
		&amp;quot;name&amp;quot;:           &amp;quot;Github User&amp;quot;,
		&amp;quot;nameHeader&amp;quot;:     &amp;quot;Item name&amp;quot;,
		&amp;quot;quantityHeader&amp;quot;: &amp;quot;Quantity&amp;quot;,
		&amp;quot;items&amp;quot;: []map[string]interface{}{
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Pen&amp;quot;,
				&amp;quot;quantity&amp;quot;: 2,
			},
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Pencil&amp;quot;,
				&amp;quot;quantity&amp;quot;: 1,
			},
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Condom&amp;quot;,
				&amp;quot;quantity&amp;quot;: 12,
			},
			{
				&amp;quot;name&amp;quot;:     &amp;quot;Beer&amp;quot;,
				&amp;quot;quantity&amp;quot;: 24,
			},
		},
	}
	doc.Render(ctx)
	doc.Save(&amp;quot;./report.xlsx&amp;quot;)
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Обработка ошибок здесь не показана, но в реальном приложении, естественно, стоит их учитывать.&lt;/p&gt;

&lt;p&gt;Буду рад любым откликам и предложениям по развитию пакета!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Умный колбэк</title>
      <link>https://ivahaev.ru/post/smart-callback/</link>
      <pubDate>Mon, 23 Nov 2015 00:57:54 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/smart-callback/</guid>
      <description>&lt;p&gt;В настоящее время сложно предложить клиентам что-то действительно уникальное, конкурентная борьба переходит в иные плоскости. Сегодняшние клиенты довольно разборчивы. Цена продукта уже не всегда играет решающую роль, покупатели ценят сервис.&lt;/p&gt;

&lt;p&gt;Естественно, многие компании придумывают различные способы привлечения и удержания клиентов. Рассмотрим вариант, как правильно настроенный на принятие входящих звонков телефонный сервис поможет не терять потенциальных и удерживать существующих клиентов.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Я специально не буду касаться модных нынче сервисов звонка с сайта, в данной статье рассматривается ситуация, когда клиент сам звонит в нашу компанию, важно его не упустить, пока горяченький.&lt;/p&gt;

&lt;h3 id=&#34;боремся-за-клиента-любой-ценой&#34;&gt;Боремся за клиента любой ценой&lt;/h3&gt;

&lt;p&gt;Потенциальный клиент, впервые пытающийся обратиться в вашу компанию по телефону, если вы не обладаете действительно уникальным продуктом, не будет терять много времени ожидая, когда ему ответит ваш специалист. Как показывает практика, ожидание ответа может составлять от 30 секунд до двух минут максимум, а когда не дожидается ответа, просто звонит в другую компанию. Возможно, ваш номер он забудет уже через минуту.&lt;/p&gt;

&lt;p&gt;Можно бороться с подобной ситуацией разными методами.&lt;/p&gt;

&lt;p&gt;Первое, что приходит в голову&amp;nbsp;&amp;mdash; увеличить количество операторов, принимающих вызовы. Это самый лучший способ, но и самый дорогой, по понятным причинам. Кроме того, операторы будут простаивать (просиживать) большую часть времени, если, конечно, у вас не непрерывный поток звонков.&lt;/p&gt;

&lt;p&gt;Второе, что можно сделать&amp;nbsp;&amp;mdash; добавить в систему обработки вызовов голосовое меню и предложить клиенты вместо ожидания заказать обратный звонок. Тоже неплохо, и даже будет работать во многих случаях. Но здесь важно, чтобы обратный звонок был совершен немедленно, т.к. клиент хочет говорить прямо сейчас. Плохая идея перезвонить сразу и поставить клиента в ту же очередь вызовов. Не каждый готов будет снова ждать, хоть и за счет компании.&lt;/p&gt;

&lt;p&gt;Третий вариант является логическим развитием второго. Если клиент не дождался, мы должны сами запланировать обратный звонок, но только так, чтобы этот звонок произвёл живой человек, т.к. чтобы с потенциальным клиентом сразу говорил специалист компании. Как опцию, можно предусмотреть предложение положить трубку и ожидать вызова оператором по мере освобождения, в виде голосового сообщения клиенту при входящем звонке. В качестве дополнительной заботы о клиенте, можно отправить ему СМС сообщение вида &lt;em&gt;&amp;laquo;К сожалению, вы не дождались ответа специалиста компании ХХХ, но мы вам обязательно перезвоним в ближайшее время!&amp;raquo;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;рассмотрим-третий-вариант-подробнее&#34;&gt;Рассмотрим третий вариант подробнее.&lt;/h3&gt;

&lt;p&gt;При поступлении входящего вызова, первым делом проверяем, является клиент новым, или он звонит повторно. В случае, если клиент уже обращался, хорошим тоном является соединение с тем же специалистом, с которым уже был разговор, причем, в зависимости от категории клиента, можно изменить приоритет вызова&amp;nbsp;&amp;mdash; например, соединить со специалистом, минуя очередь вызова. Точно так же можно поступить, если клиент ранее не звонил&amp;nbsp;&amp;mdash; сразу произвести попытку соединения со специалистом.&lt;/p&gt;

&lt;p&gt;В любом случае, если клиент не дождался ответа и положил трубку, регистрируем его номер в специальной кампании для коллбэка. Далее алгоритм следующий:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Если имеются свободные операторы, АТС производит вызов одному из операторов, сообщая, что это заявка на обратный звонок;&lt;/li&gt;
&lt;li&gt;Опционально подтверждаем готовность принять вызов;&lt;/li&gt;
&lt;li&gt;После соединения со специалистом, АТС набирает телефонный номер клиента и производит соединение со специалистом;&lt;/li&gt;
&lt;li&gt;В случае неответа или занятости номера клиента, алгоритм повторяется через некоторое время.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Как показывает практика, таким образом, приток новых клиентов повышается на величину до 70%.&lt;/p&gt;

&lt;p&gt;С удовольствием помогу настроить АТС на использование описанного алгоритма.&lt;/p&gt;

&lt;p&gt;Удачи в борьбе за клиента!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Инкремент переменной в дайлплане Астериска</title>
      <link>https://ivahaev.ru/post/inkriemient-pieriemiennoi-v-dailplanie-astieriska/</link>
      <pubDate>Sat, 14 Nov 2015 12:34:30 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/inkriemient-pieriemiennoi-v-dailplanie-astieriska/</guid>
      <description>&lt;p&gt;Если требуется реализовать какой-то счетчик в дайлплане, удобно использовать переменную канала. Но просто так изменить её значение, прибавляя единицу, не получится.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Нужно использовать выражение:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;same =&amp;gt; n,Set(REP=$[${REP} + 1])
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Глубокий дебаг астериска</title>
      <link>https://ivahaev.ru/post/deep-debug-astierisk/</link>
      <pubDate>Thu, 12 Nov 2015 16:30:30 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/deep-debug-astierisk/</guid>
      <description>&lt;p&gt;Иногда можно потерять довольно много времени, пытаясь в консоли астериска отловить ошибку выполнения &lt;strong&gt;agi&lt;/strong&gt; скрипта, или просто внешнего приложения, запускаемого из дайлплана. Есть один способ, который в документации в явном виде не описан, но очень помогает. Мы запустим &lt;strong&gt;asterisk&lt;/strong&gt; в режиме, похожем на монопольный в &lt;strong&gt;1С&lt;/strong&gt;, при этом будем видеть в его консоли все предупреждения и ошибки.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Выключаем астериск;&lt;/li&gt;
&lt;li&gt;Выполняем такую команду:
&lt;code&gt;
su asterisk
asterisk -vvvgc
&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Теперь все как на ладони!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Три частые ошибки, возникающие при разработке на Go</title>
      <link>https://ivahaev.ru/post/three-often-mistakes-wth-go/</link>
      <pubDate>Thu, 12 Nov 2015 01:32:28 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/three-often-mistakes-wth-go/</guid>
      <description>&lt;p&gt;Это перевод статьи. Раньше желания переводить не возникало, но статья очень понравилась, наверное, из-за того, что сам наступал уже на подобные грабли. Перевод достаточно вольный, но суть передает верно. Если хоть одному начинающему разработчику поможет эта статья, труды мои будут не напрасными :).&lt;/p&gt;

&lt;p&gt;Оригинал статьи доступен по адресу &lt;a href=&#34;http://bryce.is/writing/code/jekyll/update/2015/11/01/3-go-gotchas.html&#34;&gt;http://bryce.is/writing/code/jekyll/update/2015/11/01/3-go-gotchas.html&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;1-итерация-через-range&#34;&gt;1. Итерация через range&lt;/h2&gt;

&lt;p&gt;Использовать &lt;code&gt;range&lt;/code&gt; очень удобно. Перебирая срез или отображение, для каждого элемента мы получаем две переменные, в первой индекс элемента, во второй &lt;strong&gt;копия&lt;/strong&gt; значения.
Например:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index, value := range mySlice {
    fmt.Println(&amp;quot;index: &amp;quot; + index)
    fmt.Println(&amp;quot;value: &amp;quot; + value)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Но что же здесь происходит на самом деле? Рассмотрим более подробный пример:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Foo struct {
    bar string
}

func main() {
    list := []Foo{
        {&amp;quot;A&amp;quot;},
        {&amp;quot;B&amp;quot;},
        {&amp;quot;C&amp;quot;},
    }

    list2 := make([]*Foo, len(list))
    for i, value := range list {
        list2[i] = &amp;amp;value
    }

    fmt.Println(list[0], list[1], list[2])
    fmt.Println(list2[0], list2[1], list2[2])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В данном примере происходит следующее:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Создается срез структур &lt;code&gt;Foo&lt;/code&gt; под названием &lt;code&gt;list&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Определяется срез указателей на структуры &lt;code&gt;Foo&lt;/code&gt;, под названием &lt;code&gt;list2&lt;/code&gt; с длиной равной длине массива &lt;code&gt;list&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Перебираем все структуры в срезе &lt;code&gt;list&lt;/code&gt; и присваиваем указатель на структуру соответствующему элементу среза &lt;code&gt;list2&lt;/code&gt; (имеющему тот же индекс);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Вероятнее всего, мы ожидаем следующий результат работы вышеприведенного кода:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{A} {B} {C}
&amp;amp;{A} &amp;amp;{B} &amp;amp;{C}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;А на самом деле, получаем:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{A} {B} {C}
&amp;amp;{C} &amp;amp;{C} &amp;amp;{C}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Первая строка именно такая как ожидалась, а вот со второй что-то не так. Как будто бы распечатался указатель на третий элемент среза &lt;code&gt;list2&lt;/code&gt; три раза. Почему же такое произошло?&lt;/p&gt;

&lt;p&gt;Всему виной этот самый удобный &lt;code&gt;range&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i, value := range list {
    list2[i] = &amp;amp;value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go передает &lt;strong&gt;копий&lt;/strong&gt; значений элементов вместо самих значений, когда производится итерация с помощью &lt;code&gt;range&lt;/code&gt;. И когда мы создаем указатель на &lt;code&gt;value&lt;/code&gt;, на самом деле, мы создаем указатель на &lt;strong&gt;копию&lt;/strong&gt; значения. При каждой итерации, копия нового значения помещается в ту же ячейку памяти, что и предыдущее, таким образом, все указатели в срезе &lt;code&gt;list2&lt;/code&gt; приводят к одной области памяти.&lt;/p&gt;

&lt;p&gt;Правильно решить поставленную задачу можно так:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var value Foo
for var i := 0; i &amp;lt; len(list); i++ {
    value = list[i]
    list2[i] = &amp;amp;value
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Или, все-таки, с помощью &lt;code&gt;range&lt;/code&gt;, но взяв из него только индекс элемента:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i := range list {
    list2[i] = &amp;amp;list[i]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-использование-встроенной-функций-append&#34;&gt;2. Использование встроенной функций append&lt;/h2&gt;

&lt;p&gt;Срезы&amp;nbsp;&amp;mdash; один из примитивных типов в Go. То что в других языках делается с массивами, в гоу можно сделать только со срезом.
Например, нам нужно добавить значение в срез элементов типа &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;list := []int{0,1,2}
list = append(list, 3)
fmt.Println(list) // [0 1 2 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;На первый взгляд, все похоже на метод &lt;code&gt;push()&lt;/code&gt; для массивов в других языках, но срезы&amp;nbsp;&amp;mdash; это не совсем массивы и функция &lt;code&gt;append&lt;/code&gt; иногда может удивить.&lt;/p&gt;

&lt;p&gt;Рассмотрим другой пример:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    a := []byte(&amp;quot;foo&amp;quot;)
    b := append(a, []byte(&amp;quot;bar&amp;quot;)...)
    c := append(a, []byte(&amp;quot;baz&amp;quot;)...)

    fmt.Println(string(a), string(b), string(c))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Здесь мы определили срез байт и сразу же инициировали его, преобразовав в срез строку &lt;strong&gt;&amp;ldquo;foo&amp;rdquo;&lt;/strong&gt;. Далее мы добавляем срез &lt;strong&gt;[&amp;ldquo;bar&amp;rdquo;]&lt;/strong&gt; к первому срезу, присваиваем полученное переменной &lt;code&gt;b&lt;/code&gt;, после чего добавляем другой срез &lt;strong&gt;[&amp;ldquo;baz&amp;rdquo;]&lt;/strong&gt; также к первому срезу и присваиваем полученное переменной &lt;code&gt;c&lt;/code&gt;. Результатом работы данной программы будет следующее:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo foobaz foobaz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://ivahaev.ru/img/shta.jpeg&#34; alt=&#34;Шта?&#34; /&gt;
Какого? Мы-то ждали &lt;code&gt;foo foobar foobaz&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;Чтобы понять что произошло, следует разобраться с тем, а что же за звери такие эти срезы? Срез в Go&amp;nbsp;&amp;mdash; это дексриптор, который содержит три компонента:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Указатель на базовый &lt;strong&gt;массив&lt;/strong&gt; элементов. К этому массиву мы не получим прямого доступа;&lt;/li&gt;
&lt;li&gt;Емкость базового массива;&lt;/li&gt;
&lt;li&gt;Длину среза.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Так что же произошло на самом деле? Go переиспользует базовый массив в функции &lt;code&gt;append&lt;/code&gt; если он может сделать это не изменяя его емкости. Все три переменные в примере указывают на одну и ту же области памяти. Единственная разница, что срез &lt;code&gt;a&lt;/code&gt; имеет длину &lt;strong&gt;3&lt;/strong&gt;, а срезы &lt;code&gt;b&lt;/code&gt; и &lt;code&gt;c&lt;/code&gt; длину равную 6.&lt;/p&gt;

&lt;p&gt;Следует всегда помнить, что Go будет использовать тот же базовый массив, если длина нового среза будет меньшей или равной емкости изначального среза.&lt;/p&gt;

&lt;h2 id=&#34;3-затенение-переменных&#34;&gt;3. Затенение переменных&lt;/h2&gt;

&lt;p&gt;Не уверен в переводе термина (&lt;strong&gt;Variable shadowing&lt;/strong&gt;), но примерно как-то так.&lt;/p&gt;

&lt;p&gt;В Go есть один интересный оператор, который выглядит вот так: &lt;code&gt;:=&lt;/code&gt;. Из-за него некоторые говорят, что Go очень похож на Pascal, хотя в Go оператор выполняет несколько другую работу. &lt;code&gt;:=&lt;/code&gt;&amp;nbsp;&amp;mdash; это короткая форма объявления переменной с одновременным присвоением значения и типа, соответствующего переданному значению. Очень удобная форма записи, но, к сожалению, именно она и таит в себе возможность совершить ошибку.&lt;/p&gt;

&lt;p&gt;Рассмотрим следующий код:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    list := []string{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;}
    for {
        list, err := repeat(list)
        if err != nil {
            panic(err)
        }
        fmt.Println(list)
        break
    }
    fmt.Println(list)
}

func repeat(list []string) ([]string, error) {
    if len(list) == 0 {
        return nil, errors.New(&amp;quot;Nothing to repeat!&amp;quot;)
    }
    list = append(list, list...)
    return list, nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Автор считает, что это очень показательный пример. Ну что же, поверим, к тому же, он вполне себе хорошо иллюстрирует проблему. Происходит следующее:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Создается срез строк с именем &lt;code&gt;list&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;Запускается бесконечный цикл;&lt;/li&gt;
&lt;li&gt;Вызываем функцию &lt;code&gt;repeat()&lt;/code&gt;, которая возвращает новый срез и ошибку;&lt;/li&gt;
&lt;li&gt;Прерываем цикл;&lt;/li&gt;
&lt;li&gt;Печатаем &lt;code&gt;list&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Глядя на код, ожидается следующий вывод:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[a b c a b c]
[a b c a b c]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Но на деле получаем:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[a b c a b c]
[a b c]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;А все потому, что когда использовали оператор &lt;code&gt;:=&lt;/code&gt;, мы на самом деле определили новую переменную &lt;code&gt;list&lt;/code&gt; в области видимости цикла. В Go фигурные скобки создают новую область видимости. Мы это сделали для того, чтобы быстренько объявить переменную &lt;code&gt;err&lt;/code&gt; типа &lt;code&gt;error&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ivahaev.ru/img/norma.jpeg&#34; alt=&#34;Это норма&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Чтобы исправить ситуацию, нужно объявить &lt;code&gt;err&lt;/code&gt; заранее и далее использовать обычный оператор присваивания &lt;code&gt;=&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var err error
list, err = duplicate(list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;В поставке Go есть отличная утилита &lt;code&gt;go vet&lt;/code&gt;, запустив которую с опцией &lt;code&gt;-shadow&lt;/code&gt;, можно проверить код на наличие потенциальных ошибок связанных с затенением переменных.&lt;/p&gt;

&lt;p&gt;Go&amp;nbsp;&amp;mdash; отличный язык, но чтобы создавать действительно классно работающие приложения, стоит понимать что происходит у него &amp;ldquo;под капотом&amp;rdquo;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Проигрывание файла при телефонном разговоре</title>
      <link>https://ivahaev.ru/post/proighryvaniie-faila-pri-tieliefonnom-razghovorie/</link>
      <pubDate>Wed, 11 Nov 2015 01:53:02 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/proighryvaniie-faila-pri-tieliefonnom-razghovorie/</guid>
      <description>&lt;p&gt;В работе оператора колл-центра часто возникает необходимость проиграть в канал заранее заготовленные голосовые файлы, например, адреса офисов и режимы работы.&lt;/p&gt;

&lt;p&gt;Рассмотрим вариант решения данной задачи на базе &lt;strong&gt;IP PBX Asterisk&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Пример для &lt;strong&gt;FreePBX&lt;/strong&gt;, для голого астериска все делается ещё проще.&lt;/p&gt;

&lt;p&gt;Первым делом, нужно добавить сочетание клавиш на вызов макроса в &lt;code&gt;features.conf&lt;/code&gt;, или для &lt;strong&gt;FreePBX&lt;/strong&gt; в &lt;code&gt;features_applicationmap_custom.conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;playsound =&amp;gt; *6,callee,macro,playsound
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;По нажатию в разговоре *&lt;strong&gt;6&lt;/strong&gt; вызовется макрос playsound&lt;/p&gt;

&lt;p&gt;Важный момент, нужно добавить возможность вызова макроса. Для этого либо в дайлплане присваиваем переменную:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exten =&amp;gt; _+x.,n,Set(DYNAMIC_FEATURES=playsound)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Либо в &lt;strong&gt;extensions.conf&lt;/strong&gt; пишем в секции &lt;strong&gt;[globals]&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DYNAMIC_FEATURES=playsound
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Макрос и нужный контекст в дайлплане:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[macro-playsound]

exten =&amp;gt; s,1,AGI(create_spy.php,${CHANNEL})

; end of [macro-playsound]

[spy]
exten =&amp;gt; 1,1,Chanspy(${chan},v(-4)wqBbE)
exten =&amp;gt; 1,n,Hangup

exten =&amp;gt; 2,1,Answer
exten =&amp;gt; 2,n,Set(VOLUME(TX)=-3)
exten =&amp;gt; 2,n,Playback(${audio})
exten =&amp;gt; 2,n,Hangup

; end of [spy]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Файл &lt;strong&gt;create_spy.agi&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/php -q

&amp;lt;?php

$par=$argv[1];
$channel= $par;

    $uid=time();
    $f1=fopen(&amp;quot;/tmp/$uid.call&amp;quot;,&amp;quot;w&amp;quot;);
    fputs($f1,&amp;quot;Channel: LOCAL/2@spy\n&amp;quot;);
    fputs($f1,&amp;quot;MaxRetries: 0\n&amp;quot;);
    fputs($f1,&amp;quot;RetryTime: 600\n&amp;quot;);
    fputs($f1,&amp;quot;WaitTime: 30\n&amp;quot;);
    fputs($f1,&amp;quot;Context: spy\n&amp;quot;);
    fputs($f1,&amp;quot;Extension: 1\n&amp;quot;);
    fputs($f1,&amp;quot;Priority: 1\n&amp;quot;);
    fputs($f1,&amp;quot;Set: audio=custom/VOICE_FILE\nSet: chan=$channel\n&amp;quot;);
    fclose($f1);
    system(&amp;quot;mv /tmp/$uid.call /var/spool/asterisk/outgoing/&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Здесь &lt;strong&gt;VOICE_FILE&lt;/strong&gt; - это проигрываемый файл.  Не забыть сделать &lt;code&gt;chmod +x /var/lib/asterisk/agi-bin/create_spy.php&lt;/code&gt; ну или где в нашем дистрибутиве расположены &lt;strong&gt;agi&lt;/strong&gt; скрипты.&lt;/p&gt;

&lt;p&gt;Само собой, можно сделать все через &lt;strong&gt;AMI&lt;/strong&gt;, в данном случае, была задача показать вариант решения вопроса. Реализация за вами!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Blank</title>
      <link>https://ivahaev.ru/post/blank/</link>
      <pubDate>Wed, 11 Nov 2015 00:44:42 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/blank/</guid>
      <description>&lt;p&gt;В данный момент занимаюсь разработкой собственной универсальной системы автоматизации бизнес-процессов, которая называется &lt;a href=&#34;http://getblank.net&#34;&gt;&lt;strong&gt;Blank&lt;/strong&gt;&lt;/a&gt;. Данный проект интересен тем, что позволяет построить практически любую информационную систему в кратчайшие сроки. В одном довольно простом конфигурационном файле описывается как структура данных, так и бизнес-логика. Платформа сама создаёт готовый пользовательский интерфейс для работы с данными сразу после описания их структуры. Задействованы многие современные технологии. Это и &lt;strong&gt;Go&lt;/strong&gt;, &lt;strong&gt;React.js&lt;/strong&gt;, &lt;strong&gt;WAMP&lt;/strong&gt;, встроенная база данных. Гибкая настройка прав, автоматическая генерация клиентского интерфейса, простая интеграция с существующими системами. Бизнес-логика описывается на хорошо знакомом &lt;strong&gt;Javascript&lt;/strong&gt; и выполняется с помощью движка &lt;strong&gt;V8&lt;/strong&gt;.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Об авторе</title>
      <link>https://ivahaev.ru/post/about/</link>
      <pubDate>Wed, 04 Nov 2015 01:02:15 +0500</pubDate>
      
      <guid>https://ivahaev.ru/post/about/</guid>
      <description>&lt;p&gt;Меня зовут Евгений. Всю сознательную жизнь так или иначе связан с ИТ. С компьютером познакомился лет 20 назад, когда на ЭВМ Электроника, у которого экран монитора был чуть больше спичечного коробка, пытался писать программы на Бейсике. 8 лет работал в области связи&amp;nbsp;&amp;mdash; вначале в сотовых операторах, затем с нуля создавал СПД и сопутствующую инфраструктуру местного оператора Интернета и IP телефонии. Активно работал с оборудованием Cisco, далее стал поглядывать на альтернативы.&lt;/p&gt;

&lt;p&gt;В один прекрасный момент понял, что лучше всего я умею программировать (благо начал осваивать это ремесло в 1994 году), начал брать заказы на создание различных программных продуктов. В 2013 году решил полностью посвятить себя этому роду деятельности. Так как имел значительные познания и опыт работы в области связи, начал с внедрения систем IP телефонии в различных организациях. Первоначально программировал на PHP, в том числе применяя фреймворк Yii (версий 1 и 2), после активно использовал node.js. Вот уже два года как работаю, в основном, c Go (Golang).&lt;/p&gt;

&lt;p&gt;За это время удалось реализовать несколько полноценных проектов:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Система учета и обработки заявлений на осуществление межрегиональных пассажирских перевозок&lt;/strong&gt;. Внедрена в Росавтотрансе (подразделение Минтранса РФ). В качестве ядра системы использована платформа собственной разработки &lt;a href=&#34;http://getblank.net&#34;&gt;Blank&lt;/a&gt;. Бэкенд: go with embedded v8, фронтенд&amp;nbsp;&amp;mdash; ReactJS. Транспортный протокол&amp;nbsp;&amp;mdash; модифицированный WAMP.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Сервис кол-трекинга с интеграцией в CRM заказчика&lt;/strong&gt;, так же на базе платформы Blank + IP PBX Freeswitch.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Система автоматического обзвона Peach Dialer v1&lt;/strong&gt;. В работе использовал IP PBX Asterisk, PHP, MySQL, в том числе есть версия с интеграцией в SugarCRM. Система установлена порядка десяти раз по всему миру - в России, Украине, США, Норвегии, Новой Зеландии, Израиле.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Система автоматического обзвона Peach Dialer v2&lt;/strong&gt; (&lt;a href=&#34;http://peach-dialer.com&#34;&gt;http://peach-dialer.com&lt;/a&gt;). Также основана на Asterisk, но бэкенд переписан на Node.js + MongoDB, фронтенд реализован на Angular.js. Вторая версия уже гораздо ближе к полноценному Call центру, имеет средства мониторинга, зачатки CRM. Активно используется протокол Websocket. В настоящий момент в эксплуатации у нескольких заказчиков в России.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Система мониторинга за подвижными объектами&lt;/strong&gt;. Изначально задумывалась как охранная система за детьми в детских дошкольных учреждениях, в дальнейшем добавлен функционал сбора данных с GPS трекеров различных производителей, а так же с мобильных телефонов на базе Android и iOS. Все подсистемы бэкенда написаны на Go - веб-сервер, сервер сбора данных с GPS, WiFi и Bluetooth трекеров, коннектор к АТС. В качестве базы данных используется MongoDB с геоиндексами. Фронтенд написан с использованием фреймворка Angular.js, библиотека отображения карт - Leaflet. Проект в данный момент в тестовой эксплуатации в городе Томске.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Сервис обратного звонка&lt;/strong&gt; (&lt;a href=&#34;http://cbp.kz&#34;&gt;http://cbp.kz&lt;/a&gt;, Казахстан) - аналог callbackhunter с казахским лицом. Бэкенд на Go + встроенная база данных, фронтенд - Angular.js. Подсистема телефонии построена на базе Freeswitch.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Модуль расширенной статистики для NeoPBX&lt;/strong&gt; (&lt;a href=&#34;http://neopbx.ru&#34;&gt;http://neopbx.ru&lt;/a&gt;). Достаточно глубокий анализ CDR записей, построение полной карты звонка. Asterisk + PHP + MySQL.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;плюс множество внедрений систем IP телефонии различной сложности, CRM, CMS систем и прочих интернет-магазинов.&lt;/p&gt;

&lt;p&gt;В данный момент занимаюсь разработкой собственной универсальной системы автоматизации бизнес-процессов, которая называется &lt;a href=&#34;http://getblank.net&#34;&gt;Blank&lt;/a&gt;. Данный проект интересен тем, что позволяет построить практически любую информационную систему в кратчайшие сроки. В одном довольно простом конфигурационном файле описывается как структура данных, так и их представление в веб интерфейсе. Задействованы многие современные технологии. Это и &lt;strong&gt;Go, и React.js, и WAMP,&lt;/strong&gt; встроенная база данных. Гибкая настройка прав, автоматическая генерация клиентского интерфейса, простая интеграция с существующими системами. Бизнес-логика описывается на хорошо знакомом &lt;strong&gt;Javascript&lt;/strong&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>